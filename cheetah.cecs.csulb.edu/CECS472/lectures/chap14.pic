\def\chapternumber{Chapter 14 --- Multiple Protocol Servers -- 15 March 2006}
\input slides.tex
\centerline{\bbf Chapter 14}
\centerline{Multiple Protocol Servers}

{\bit Motivation:}
Separate servers take more RAM and, because of context switches, more CPU.
One server handling both UDP and TCP connections is efficient.

{\bit OS support:}
UDP and TCP are separate connections
\break
even on the same port.

{\bit Implementation:}
Open one socket for TCP and one {\bit on the same port} for UDP.
Use {\ltt{}select} to determine which one needs service. 

Example: The daytime server has both UDP and TCP sockets.

A TCP client does a ``connect", which is handled by an accept, write, close.

A UDP client does a ``send", which is handled by a receive-from, send-to.
\newslide
\centerline{\bbf Detailed Analysis}

See section 14.5 for code.

{\cprogram
int main(int argc,char *argv[]){
  char *service="daytime";
  char buf[LINELEN+1];
  struct sockaddr_in fsin;
  unsigned int alen;
  int tsock;
  int usock;
  int nfds;
  fd_set rfds;
  switch (argc){
   ...
  }
  tsock=passiveTCP(service,QLEN);
  usock=passiveUDP(service);
@endprogram}
{\ltt{}tsock}: is the TCP master socket
\break
{\ltt{}usock}: is the UDP socket
\break
{\ltt{}nfds}: the size of the set
\break
{\ltt{}rfds}: the set, instead of a copy, it is rebuilt each time.
\break
Both the TCP and UDP sockets are set up

The {\ltt{}switch} and other declarations are identical to other servers.

\newslide

{\cprogram
nfds=MAX(tsock,usock)+1;
FD_ZERO(&rfds);
while(1) {
  FD_SET(tsock,&rfds);
  FD_SET(usock,&rfds);
  if (select...)
    errexit(...);
@endprogram}

{\ltt{}nfds} is set to be as small as possible.

The set is constructed by the two {\ltt{}FD_SET} calls.
\break
(There is no {\ltt{}afds} and no {\ltt{}memcpy})
\break
The {\ltt{}FD_ZERO} is outside the loop because, nothing
ever turns on any {\ltt{}FD_SET} bits.
({\ltt{}select} turns some bits off).

The {\ltt{}select} call is unchanged.
\newslide

{\cprogram
if (FD_ISSET(tsock,&rfds) {
  int ssock;
  alen = sizeof(fsin);
  ssock=accept(tsock,
          (struct sockaddr *)&fsin,&alen);
  if (ssock < 0)
    errexit(...);
  daytime(buf);
  (void)write(ssock,buf,strlen(buf),0
          (struct sockaddr *)&fsin,sizeof(fsin));
  close(ssock);
}
@endprogram}

Activity on the {\ltt{}tsock} means a client has done a {\ltt{}connectTCP}.

The code is the standard TCP daytime serer code;
accept, get the time, write the string back.

The slave socket needs to be closed because the server is done with the client.
\newslide

{\cprogram
if (FD_ISSET(usock,&rfds) {
  alen = sizeof(fsin);
  if (recvfrom(usock,buf,sizeof(buf),0,
        (struct sockaddr *)&fsin, &alen)<0)
    errexit(...)
  daytime(buf);
  (void)sendto(usock,buf,strlen(buf),0
          (struct sockaddr *)&fsin,sizeof(fsin));
}
@endprogram}

Activity on the {\ltt{}usock} means a client has done a {\ltt{}connectUDP}
and a {\ltt{}write}.

The code is the standard UDP daytime server code;
receive from, get the time, send the time back to the return address

\newslide
\centerline{\bbf Behavior}

If a client does a {\ltt{}connectTCP}:

Input will arrive on {\ltt{}tsock}
\break
Server will do an accept.

If a client does a {\ltt{}write} or {\ltt{}send} (after a {\ltt{}connectUDP}):

Input will arrive on {\ltt{}usock}
\break
Server will do a recvfrom.

In both cases this server replies.
\vfill
\centerline{\bbf Extensions}

The above code works only for short requests.
\break
For long requests; possibly code similiar to Chapter 13 will do.

Consider echo.
The interaction is long (until EOF keyboard).
\break
We can do UDP receive from/send to for many clients.
We don't know how many clients there are.
\break
We can use the {\ltt{}afds}, {\ltt{}memcpy} code for handling multiple TCP
clients found in Chapter 13.
\break
(Don't forget to put the {\ltt{}usock} in the {\ltt{}afds}.)

\bye

