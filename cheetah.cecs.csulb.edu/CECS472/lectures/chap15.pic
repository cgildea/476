\def\chapternumber{Chapter 15 --- Multiple Service Servers -- 29 June 2007}
\input slides.tex
\centerline{\bbf Chapter 15}
\centerline{Multiple Service Servers}

{\bit Outline:}
\ind{}Motivation
\ind{}Iterative, Connectionless Server.
\ind{}Concurrent, Connection-Oriented Server.
\ind{}Single-Process Server
\ind{}Flexibility of Invoking Separate Programs
\ind{}Multiservice, Multiprotocol Designs
\ind{}Example Multiservice Server
\ind{}BSD super server: inetd
\newslide

{\bit Motivation:}

Consolidation of servers reduces:  
\break
--the number of executing processes
\break
--the total code required

Principle: use a separate socket (and port) for each service, 
but have one program handle them all.

Otherwise similar to the corresponding single service Server.

{\bit Iterative, Connectionless, Multiservice Server}
\ind{1}  Opens a set of UDP sockets.
\ind{2}  Binds each one to a well-known port for one of the
services being offered.
\ind{3} A table maps services to sockets (for each
descriptor, the table records the address of a procedure 
to call for service).
\ind{4}  Call select to wait for a datagram to arrive.
\ind{5}  Examine the descriptor and call the appropriate service procedure.
\ind{6}  Return to the select call.
\newslide

Iterative is good for handling short, non-interactive services.

{\bit  Iterative, Connection-Oriented, Multiservice Server}
\ind{1} Opens one socket for each service and binds each one to
the appropriate well-known port.
\ind{2} A table maps services to sockets (for each
descriptor, the table records the address of a procedure 
\ind{3} Calls select to wait for an incoming connection request.
\ind{4}  When a request arrives, calls accept to create a new
socket for the incoming connection.
\ind{5} Uses the new socket to interact with the client, then closes
the socket.
\ind{6}  Return to the select call.

\newslide
{\bit Concurrent, Connection-Oriented, Single-Process Multiservice Server}
\ind{1} Opens one master socket for each service and binds each one to
the appropriate well-known port.
\ind{2} A table maps services to sockets (for each
descriptor, the table records the address of a procedure 
\ind{3} Calls select to wait for incoming connection requests master sockets
or incoming data to read on slave sockets.
\ind{4a}  For connect requests, calls {\ltt{}accept} to create a new
socket for the incoming connection.
\ind{4b}  For incoming data, calls the appropriate procedure to provide service.
\ind{5}  Return to the select call.

\newslide
{\bit Concurrent, Connection-Oriented, Multi-Process Multiservice Server}

\ind{1} Opens one master socket for each service and binds each one to
the appropriate well-known port.
\ind{2} A table maps services to sockets (for each
descriptor, the table records the address of a procedure 
\ind{3} Calls select to wait for incoming connection requests.
\ind{4}  Creates a slave processes for each new connection.
\ind{5}  Each slave handles service for client.

\vt
{\bit Software Design}

Break code into independent components using
separately compliled programs.
\break
Compile those modules which change and relink.

Multi-process Servers: {\ltt{}fork}/{\ltt{}exec} allow call of a separately
compiled (and maintained program).
\newslide
\centerline{\bbf Example Multiservice Server}

see Section 15.9 for code

Four services: echo, chargen, daytime, and time

{\program
struct service{
  char *sv_name;      /* ASCII name of service */
  char sv_useTCP;     /* 0=UDP 1=TCP           */
  int sv_sock;        /* socket descriptor     */
  int (*sv_func)(int);/* function to call      */
}
\endprogram}

{\ltt{}svent} is an array of 4 of these
\break
Each entry is used to store the information about one of the services.
\break
C note: {\ltt{}sv_func} stores the address of a function.
\break
function calls are by address
\break
{\ltt{}svent[3]->sv_func(4)}
will call the function whose address is found in the 4th record 
({\ltt{}TCPtimed}), and ask it to use the socket found in descriptor 4.
\break
{\ltt{}svent[3]->sv_sock} is the master socket for the service

Array {\ltt{}fd2sv} to map from the descriptor back to
an entry in svent (reverse map).
%\break
%Ex: if {\ltt{}daytime} was {\ltt{}passiveTCP}'d to socket 6,
%then {\ltt{}fd2sv[6]} gets a {\ltt{}2}
%\break
%({\ltt{}daytime} is at position 2 in the {\ltt{}svent} array)
\newslide
\centerline{Structure Before socket allocation}

\vt
{\railroadfont
.PS
entryht = 0.25i
entrywd = 1.4i
codeht = 1.0i
codewd = 1.0i
sockht = 0.3i
sockwid = 0.3i
# svent
# parameters: Id, where, service name, TCP/UDP, Socket, function pointer
  define svent X
    move right to $2 + (0, -2*entryht)
    $1:
    [
      Main:  box wid entrywd ht 4*entryht with .nw at $2
      Name:  box wid entrywd ht entryht $3 with .n at Main.n
      Tcp:   box wid entrywd ht entryht $4 with .n at Name.s
      Sock:  box wid entrywd ht entryht $5 with .n at Tcp.s
      Func:  box wid entrywd ht entryht with .n at Sock.s
    ] 
    move right to $1 X

# end svent

Servs: box wid entrywd ht 16*entryht
svent(Eentry, Servs.nw, "\"echo\"", "TCPSERV", "NOSOCK", Acode.w)
move to 1/4 between Servs.nw and Servs.sw
Chstart: Here
svent(Centry, Chstart.nw, "\"chargen\"", "TCPSERV", "NOSOCK", Acode.w)
move to 1/2 between Servs.nw and Servs.sw
Daystart: Here
svent(Dentry, Daystart, "\"daytime\"", "TCPSERV", "NOSOCK", Acode.w)
move to 3/4 between Servs.nw and Servs.sw
Timstart: Here
svent(Tentry, Timstart, "\"time\"", "TCPSERV", "NOSOCK", Acode.w)
Ecode: box wid codewd ht codeht with .nw at Servs.ne + (1.5i, -0.5i) "echo()" "function" "code"
Ccode: box wid codewd ht codeht with .n at Ecode.s "chargen()" "function" "code"
Dcode: box wid codewd ht codeht with .n at Ccode.s "daytime()" "function" "code"
Tcode: box wid codewd ht codeht with .n at Dcode.s "time()" "function" "code"
arrow from Eentry.Func.c to Ecode.nw
arrow from Centry.Func.c to Ccode.nw
arrow from Dentry.Func.c to Dcode.nw
arrow from Tentry.Func.c to Tcode.nw
"svent" at Servs.n above
Sockets: box wid sockwid ht 8*sockht with .e at Servs.w + (-1.0i, 0)
"fd2sv" at Sockets.n above
Aa: box wid sockwid ht sockht with .n at Sockets.n "?"
"0 " at Aa.w rjust
Ab: box wid sockwid ht sockht with .n at last box.s "?"
"1 " at Ab.w rjust
Ac: box wid sockwid ht sockht with .n at last box.s "?"
"2 " at Ac.w rjust
Ad: box wid sockwid ht sockht with .n at last box.s "?"
"3 " at Ad.w rjust
Ae: box wid sockwid ht sockht with .n at last box.s "?"
"4 " at Ae.w rjust
Af: box wid sockwid ht sockht with .n at last box.s "?"
"5 " at Af.w rjust
Ag: box wid sockwid ht sockht with .n at last box.s "?"
"6 " at Ag.w rjust
Ah: box wid sockwid ht sockht with .n at last box.s "?"
"7 " at Ah.w rjust
.PE
\centerline{\box\graph}}

Strings are for human interface purposes and for use
with the {\ltt{}passiveUDP} and {\ltt{}passiveTCP} functions.

No sockets are entered (yet)
\break
0,1,2: are {\ltt{}stdin}, {\ltt{}stdout} and {\ltt{}stderr} and will be unused
\newslide
\centerline{Structure after socket allocation}

\vt
{\railroadfont
.PS
entryht = 0.25i
entrywd = 1.4i
codeht = 1.0i
codewd = 1.0i
sockht = 0.3i
sockwid = 0.3i
# svent
# parameters: Id, where, service name, TCP/UDP, Socket, function pointer
  define svent X
    move right to $2 + (0, -2*entryht)
    $1:
    [
      Main:  box wid entrywd ht 4*entryht with .nw at $2
      Name:  box wid entrywd ht entryht $3 with .n at Main.n
      Tcp:   box wid entrywd ht entryht $4 with .n at Name.s
      Sock:  box wid entrywd ht entryht $5 with .n at Tcp.s
      Func:  box wid entrywd ht entryht with .n at Sock.s
    ] 
    move right to $1 X

# end svent

Servs: box wid entrywd ht 16*entryht
svent(Eentry, Servs.nw, "\"echo\"", "TCPSERV", "3", Acode.w)
move to 1/4 between Servs.nw and Servs.sw
Chstart: Here
svent(Centry, Chstart.nw, "\"chargen\"", "TCPSERV", "4", Acode.w)
move to 1/2 between Servs.nw and Servs.sw
Daystart: Here
svent(Dentry, Daystart, "\"daytime\"", "TCPSERV", "5", Acode.w)
move to 3/4 between Servs.nw and Servs.sw
Timstart: Here
svent(Tentry, Timstart, "\"time\"", "TCPSERV", "6", Acode.w)
Ecode: box wid codewd ht codeht with .nw at Servs.ne + (1.5i, -0.5i) "echo()" "function" "code"
Ccode: box wid codewd ht codeht with .n at Ecode.s "chargen()" "function" "code"
Dcode: box wid codewd ht codeht with .n at Ccode.s "daytime()" "function" "code"
Tcode: box wid codewd ht codeht with .n at Dcode.s "time()" "function" "code"
arrow from Eentry.Func.c to Ecode.nw
arrow from Centry.Func.c to Ccode.nw
arrow from Dentry.Func.c to Dcode.nw
arrow from Tentry.Func.c to Tcode.nw
"svent" at Servs.n above
Sockets: box wid sockwid ht 8*sockht with .e at Servs.w + (-1.0i, 0)
"fd2sv" at Sockets.n above
Aa: box wid sockwid ht sockht with .n at Sockets.n "?"
"0 " at Aa.w rjust
Ab: box wid sockwid ht sockht with .n at last box.s "?"
"1 " at Ab.w rjust
Ac: box wid sockwid ht sockht with .n at last box.s "?"
"2 " at Ac.w rjust
Ad: box wid sockwid ht sockht with .n at last box.s
"3 " at Ad.w rjust
Ae: box wid sockwid ht sockht with .n at last box.s
"4 " at Ae.w rjust
Af: box wid sockwid ht sockht with .n at last box.s
"5 " at Af.w rjust
Ag: box wid sockwid ht sockht with .n at last box.s
"6 " at Ag.w rjust
Ah: box wid sockwid ht sockht with .n at last box.s "?"
"7 " at Ah.w rjust
arrow from Ad.c to Eentry.nw
arrow from Ae.c to Centry.nw
arrow from Af.c to Dentry.nw
arrow from Ag.c to Tentry.nw
.PE
\centerline{\box\graph}}

\newslide
\centerline{Section 15.9 code details}

{\cprogram
#define  UDP_SERV  0
#define  TCP_SERV  1
#define  NOSOCK -1 /*an invalid socket descriptor*/

struct service {
  char  *sv_name;
  char  sv_useTCP;
  int   sv_sock;
  int   (*sv_func)(int);
};

struct service svent[] = {
  {"echo",TCP_SERV,NOSOCK,TCPechod },
  {"chargen",TCP_SERV,NOSOCK,TCPchargend },
  {"daytime",TCP_SERV,NOSOCK,TCPdaytimed },
  {"time",TCP_SERV,NOSOCK,TCPtimed },
  {0, 0, 0, 0 }
};
@endprogram}

The defines set up values to go into the structure.

The structure is declared and initialized to have everything
but the descriptor (socket) number.
\newslide

{\cprogram
int main(int argc, char *argv[]) {
  struct service  *psv,    /*service table pointer*/
    *fd2sv[NOFILE];    /*map fd to service pointer*/
  int  fd, nfds;
  fd_set  afds, rfds;
  nfds = getdtablesize();
  FD_ZERO(&afds);
  for (psv = &svent[0]; psv->sv_name; ++psv) {
    if (psv->sv_useTCP)
      psv->sv_sock = passiveTCP(psv->sv_name, QLEN);
    else
      psv->sv_sock = passiveUDP(psv->sv_name);
    fd2sv[psv->sv_sock] = psv;
    FD_SET(psv->sv_sock, &afds);
  }
@endprogram}

{\ltt{}for}: go through the array of services and fill in the socket numbers.
\break
a 0 for the name indicates the end of the array

Open either a TCP master socket or
\break
a UDP socket for each service.

Also, fill in the reverse lookup array {\ltt{}fd2sv}
\newslide

{\cprogram
while (1) {
  memcpy(&rfds, &afds, sizeof(rfds));
  if (select(nfds, &rfds, NULL, NULL, NULL) < 0) {
    if (errno == EINTR) continue;
    errexit(...);
  }
@endprogram

{\ltt{}while(1)} the main service loop,

{\ltt{}memcpy...select}: wait for a connect/message
on any of the ports we have open.

{\ltt{}EINTR}: Falling out the select because the program
has received a {\ltt{}SIGCHILD} signal is handled by going back around the
while loop to the {\ltt{}select}.
This is necessary since we have {\ltt{}fork} and a {\ltt{}reaper}.

\newslide
{\cprogram
  for (fd=0; fd<nfds; ++fd)
    if (FD_ISSET(fd, &rfds)) {
      psv = fd2sv[fd];
      if (psv->sv_useTCP)
        doTCP(psv);
      else
        psv->sv_func(psv->sv_sock);
    }
}
@endprogram

{\ltt{}for} process each connect/message.
\break
This is the real service inside the service loop.
\break
Use the reverse map ({\ltt{}fd2sv}) to find the service entry information
\break
If the service entry indicates this is a UDP function,
\break
just call the service function passing the socket.

If the service entry indicates this is a TCP function,
call {\ltt{}doTCP} because TCP needs additional setup
before calling the service procedure
\newslide

{\cprogram
void doTCP(struct service *psv) {
  struct sockaddr_in fsin;
  int  alen, ssock;
  alen = sizeof(fsin);
  ssock=accept(psv->sv_sock,
    (struct sockaddr *)&fsin, &alen);
  if (ssock < 0) errexit(...);
  switch (fork()) {
  case 0:  break;
  case -1: errexit(...);
  default: (void) close(ssock);
    return;    /* parent */
  }
  exit(psv->sv_func(ssock)); /* child */
}
@endprogram

This is the special TCP setup.

do an {\ltt{}accept} to set up the slave socket

fork a child that calls the service function
\break
when the service function returns, the child exits

{\ltt{}return} takes the parent back to the main program,
which for-loops to the next {\ltt{}rfds} needing service.
\newslide

The service function must be correctly programmed.

For TCP, the service function is passed the slave socket
on which it must do any necessary reads and writes.

The {\ltt{}accept} has been done, the {\ltt{}close} is not required because
of the {\ltt{}exit}

\vf
For UDP, the service function must do a {\ltt{}recvfrom}
so has an address to use for the {\ltt{}sendto}.

\vf
When done, the service function should return; which will trigger the exit.
\newslide
\centerline{\bbf inetd}

BSD UNIX super server

\ind{} Supplies many small TCP/IP services
\ind{} Services can be added to (deleted from) inetd using a configuration file

{\ltt{}/etc/inetd.conf} the config file

Service name--such as {\ltt{}telnet}

Socket type--{\ltt{}dgram}/{\ltt{}stream}

Service type--{\ltt{}udp}/{\ltt{}tcp}

wait/nowait--single process/multiprocess (fork)

user--privilege level (actually user name)

service procedure--name of the executable file, internal indicates
a tiny service like time provided directly by inetd.

display name--what to show to {\ltt{}ps}
\vt
Only one server is running waiting for many things.

Specific servers are not started unless needed.
\bye
/* superd.c -- multi-service server*/
#define  UDP_SERV  0
#define  TCP_SERV  1
#define  NOSOCK    -1  /* an invalid socket descriptor  */

struct service {
  char  *sv_name;
  char  sv_useTCP;
  int   sv_sock;
  int   (*sv_func)(int);
};

struct service svent[] =
  {  { "echo", TCP_SERV, NOSOCK, TCPechod },
    { "chargen", TCP_SERV, NOSOCK, TCPchargend },
    { "daytime", TCP_SERV, NOSOCK, TCPdaytimed },
    { "time", TCP_SERV, NOSOCK, TCPtimed },
    { 0, 0, 0, 0 },
  };

int main(int argc, char *argv[]) {
  struct service  *psv,    /* service table pointer  */
    *fd2sv[NOFILE];    /* map fd to service pointer  */
  int  fd, nfds;
  fd_set  afds, rfds;
  nfds = getdtablesize();
  FD_ZERO(&afds);
  for (psv = &svent[0]; psv->sv_name; ++psv) {
    if (psv->sv_useTCP)
      psv->sv_sock = passiveTCP(psv->sv_name, QLEN);
    else
      psv->sv_sock = passiveUDP(psv->sv_name);
    fd2sv[psv->sv_sock] = psv;
    FD_SET(psv->sv_sock, &afds);
  }
  while (1) {
    memcpy(&rfds, &afds, sizeof(rfds));
    if (select(nfds, &rfds, NULL, NULL, NULL) < 0) {
      if (errno == EINTR) continue;
      errexit("select error: %s\n", strerror(errno));
    }
    for (fd=0; fd<nfds; ++fd)
      if (FD_ISSET(fd, &rfds)) {
        psv = fd2sv[fd];
        if (psv->sv_useTCP)
          doTCP(psv);
        else
          psv->sv_func(psv->sv_sock);
      }
  }
}

void doTCP(struct service *psv) {
  struct sockaddr_in fsin;
  int  alen, ssock;
  alen = sizeof(fsin);
  ssock = accept(psv->sv_sock, (struct sockaddr *)&fsin, &alen);
  if (ssock < 0) errexit("accept: %s\n", strerror(errno));
  switch (fork()) {
  case 0:  break;
  case -1: errexit("fork: %s\n", strerror(errno));
  default: (void) close(ssock);
    return;    /* parent */
  }
  exit(psv->sv_func(ssock)); /* child */
}
