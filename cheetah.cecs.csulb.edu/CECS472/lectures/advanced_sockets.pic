\def\chapternumber{Advanced Sockets -- 4 January 2006}
\input slides.tex
\centerline{\bbf Advanced Socket Capabilities}
\centerline{\bbf Socket I/O}

A buffer space issue that occurs in commercial programs that
we haven't had to handled, because our homeworks have
been student size.

Issue: TCP can run out of buffer space.
\break
Only a limited amount of system/network buffer space is made allocated by
the system; if you exceed that, the write may fail.

If the data transfers to the server are large, the
server can become clogged and the client can stop at
the {\ltt{}write}.

If the client is using blocking I/O,
it can pause at the {\ltt{}write} forever.
\newslide
\centerline{\bbf Example}
Client:

{\cprogram
  // send data to server
  write(ssock,buf,sizeof(buf));
  // read config
  n = read(ssock,buf,sizeof(buf));
  // ...
  // read reply
  n = read(ssock,buf,sizeof(buf));
@endprogram}

Server:

{\cprogram
  // send config
  write(ssock,buf,sizeof(buf));
  // read client data
  n = read(ssock,buf,sizeof(buf));
  // ...
  // read to client
  n = write(ssock,buf,sizeof(buf));
@endprogram}

Solution 0: avoid having both client and server do writes.
\break
May not be possible in context of some programs.
\newslide
Solution 1: the system allocates the default size, you can change that.
({\ltt{}man 7 socket})
\vt

{\cprogram
int bufferSize = 8388608; //8M
// Also can do with SO_RCVBUF
int buffSizeResult = setsockopt(ssock, SOL_SOCKET,
  SO_SNDBUF, &bufferSize, sizeof(bufferSize));
int getsize;  // See what it gave us.
int getsizesize = sizeof(getsize);
int result = getsockopt(ssock, SOL_SOCKET,
   SO_SNDBUF, &getsize, &getsizesize);
@endprogram}

The maximum amount that can be allocated is set by the {\ltt{}sysctl}s
{\ltt{}rmem_max} and {\ltt{}wmem_max}.

Note: on a buffer back up, the data is either in `your' send buffer or `his'
receive buffer.
With a single process concurrent server (such as chat), increasing
the send buffer distributes the data backup amoung the clients;
\break
increasing the receive buffer doesn't scale with the number of clients.

Note: You can still clog, it just takes bigger writes.
\newslide
Solution 2: system buffer space will be freed when someone does a read,
so trying again later works.

More general idea, I/O is normally blocking,
\break
the program waits until the read/write is done.
\break
You can set I/O to be non-blocking
\break
If the I/O would block an error ({\ltt{}< 0}) is returned
and {\ltt{}errno} is set to {\ltt{}EAGAIN}

The {\ltt{}fcntl} command is used to set the non-blocking flag on
a socket (or any descriptor).

Example (spinlock loop):

{\cprogram
fcntl(ssock,F_SETFL,O_NONBLOCK);
int result;
while (1){
   result = read(ssock,buf,sizeof(buf));
   if (result < 0){
     if (errno != EAGAIN) {
       errexit();
     }
     else sleep(1); //blocked, wait and try again
   }
   else break; // good read
}
@endprogram}

{\ltt{}select} is a better way to go with reads.
\newslide
\centerline{\bbf Non-blocking writes}

{\cprogram
int sendsize = 999;
int strt = 0;
int result;
fcntl(ssock,F_SETFL,O_NONBLOCK);
while (sendsize > 0) {
  result = write(ssock,&(buf[strt]),sendsize);
  if (result < 0){
     if (errno != EAGAIN) {
         errexit();
     }
  }
  else
  {
    strt += result;
    sendsize -=result;
  }
}
@endprogram}

Non-blocking write:
\break
On {\ltt{}EAGAIN} we sent nothing, send again.
\break
On {\ltt{}result>=0} might have written less than {\ltt{}sendsize}
so track ({\ltt{}strt}) where the unsent portion of the buffer begins
and send the remainder of the buffer on later writes.
\newslide
\centerline{\bbf Interrupt driven I/O}

You can set a descriptor so a signal is sent when I/O is available.

{\cprogram
// Send me an SIGIO signal on I/O events
fcntl(ssock,F_SETFL,O_ASYNC);
// instead of SIGIO, send this sig
fcntl(ssock,F_SETSIG,SIGHUP); 
@endprogram}

Asynchronous I/O must use the sigaction form of the
signal handler.

{\cprogram
void ioHdlr(int sig);
struct sigaction act;
act.sa_handler = ioHdlr;
act.sa_mask = SIGHUP;
act.sa_flags = 0;
sigaction(SIGIO,&act,NULL);
@endprogram}

Call the function {\ltt{}ioHdlr} when a {\ltt{}SIGIO} happens.
\break
Mask {\ltt{}SIGHUP} (in addition to {\ltt{}SIGIO}).

Do the {\ltt{}sigaction} before the {\ltt{}fcntl}.

Simplistic handler:

{\cprogram
void ioHdlr(int sig) {
  read(ssock, buf,sizeof(buf));
};
@endprogram}
\newslide
\centerline{\bbf Unix (local) domain sockets}

A non-network socket implementation is available under Unix.
\break
These are called Unix domain or local domain sockets.
\break
They are invisible from outside your machine.

{\ltt{}AF_LOCAL} \qquad or \qquad {\ltt{}AF_UNIX}
\break
{\ltt{}PF_LOCAL} \qquad or \qquad {\ltt{}PF_UNIX}
\vt

{\cprogram
#include <sys/un.h>
int msock = socket(PF_LOCAL, SOCK_STREAM, 0);
struct sockaddr_un serveraddress;
serveraddress.sun_family = AF_LOCAL;
strcpy(serveraddress.sun_path,"/tmp/socketfile");
bind(msock, (struct sockaddr *)&serveraddress,
  SUN_LEN(&serveraddress));
@endprogram}

The Unix version of {\ltt{}sockaddr} is used.
A path (file name) replaces the internet address/port pair.

Client side:

{\cprogram
int ssock = socket(PF_LOCAL, SOCK_STREAM, 0);
serveraddress.sun_family = AF_LOCAL;
strcpy(serveraddress.sun_path,"/tmp/socketfile");
connect(ssock,(struct sockaddr *)&serveraddress,
  SUN_LEN(&serveraddress));
@endprogram}

\newslide
\centerline{\bbf Unix domain semantics}

If the ``socket" file exists
it is assumed that a server is running.

1) You cannot bind to an existing file.

2) After the socket close, the {\ltt{}unlink} system
call still needs to be used to remove the file.

3) A crashed server leaves a dangling file, which needs
to be removed by hand (bad OS design on this one).

\vf
The sample code is ``primitive",
\break
the {\ltt{}bind}, {\ltt{}connect} and other commands should have
\break
{\ltt{} if (... < 0) errexit(...);}
\break
code attached.
\break
Otherwise you won't know what went wrong.

\newslide
\centerline{\bbf Other IP protocols}

These are available although implementations may be limited

{\ltt{}socket(PF_LOCAL,SOCK_SEQPACKET,0)}

TCP with boundaries preserved.
\break
Your {\ltt{}read} be big enough to read the whole packet.
\break
Not available with {\ltt{}AF_INET}.
\vt

{\ltt{}socket(PF_INET,SOCK_RDM,0)}

Reliable UDP. 
\break
Packets delivery guaranteed.
\break
Order of delivery is not guaranteed.
\bye
