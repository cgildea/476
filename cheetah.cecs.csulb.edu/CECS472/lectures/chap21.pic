\def\chapternumber{Chapter 21 --- RPC -- 16 January 2001}
\input slides.tex
\centerline{\bbf Chapter 21}
\centerline{Remote Procedure Calls}

Model 1) Communication-Oriented

Design the functional specifications of client/server and 
how they communicate. (sockets)
\vt
Model 2) Application-Oriented

Build the program in a procedural language (C) and
put some procedures on a separate computer. (RPCs)

Call procedure on another machine and wait for the return.
\vt
Program design/debugging advantages:

A comfortable (familiar) way to program.

You can build/test on a single machine as a normal program,
then split.
\newslide
\centerline{\bbf RPC vs Local}
\centerline{Local Calls}
\vt
{\railroadfont
.PS
Main: box wid 3i ht 0.5i "Main Program"
Proc: box wid 3i ht 0.5i with .n at Main.s + (0,-0.5i) "procedures"
Call: line -> down 0.5i from 1/2 between Main.sw and Main.s
Rtrn: line <- down 0.5i from  1/2 between Main.s and Main.se
" call" at Call.c ljust
" return" at Rtrn.c ljust
.PE
\centerline{\box\graph}}

Parameters/results are passed using memory.
\break
Must know where to parameters/results (stack)
\vt
\centerline{Remote Calls}

\vt
{\railroadfont
.PS
Main: box wid 3i ht 0.5i "Main Program"
Proc: box wid 3i ht 0.5i with .w at Main.e + (0.5i, 0) "procedures"
Net: box wid 6.5i ht 0.5i with .nw at Main.sw + (0, -0.5i) "network"
Callm: line -> down 0.5i from 1/2 between Main.sw and Main.s
Rtrnm: line <- down 0.5i from 1/2 between Main.s and Main.se
Callp: line <- down 0.5i from 1/2 between Proc.s and Proc.se
Rtrnp: line -> down 0.5i from 1/2 between Proc.sw and Proc.s
" call" at Callm.c ljust
" return" at Rtrnm.c ljust
" call" at Callp.c ljust
" return" at Rtrnp.c ljust
line dashed down 0.1i from Rtrnp.end
line dashed left to (Rtrnm.end.x,Here.y)
line dashed up 0.1i
line dashed down 0.4i from Callm.end
line dashed right to (Callp.end.x,Here.y)
line dashed up 0.4i
.PE
\centerline{\box\graph}}
Parameters/results must passed over network
\newslide
\centerline{\bbf RPC Overview }
\vt
\ind{1)} Copy the parameters over.
\ind{2)} Call the remote procedure.
\ind{3)} Copy the answers back.
\ind{4)} Return to the caller.

Calls are expensive,
\break
once you jump, stay a while.

Call/copy uses UDP or TCP
\break
(i.e. sockets)

Caller acts as client
\break
Called procedure acts as server

You can't pass/return pointers,
\break
you must copy the data.

A procedure uses a fixed number of parameters.
\vt
Detail: how to handle parameter and return values?
\break
Solution: Allow only one parameter and result,
\break
a single structure that contains everything.
\break
XDR the parameter and result.
\newslide
\centerline{\bbf Remote Programs}
\vt
A set of remote procedures
\break
with shared global data
\vt
Calling standard procedures--by address
\break
Relocatable: branch indirect (not direct)
\break
Each procedure is assigned a number by the compiler
\break
Call the procedure by number.
\break
Look up address in an array.

Calling remote programs/procedures:
\break
Assign each remote program a number.
\break
Assign each procedure in a program a number.

Remote call:
\ind{1)} machine
\ind{2)} program number
\ind{3)} procedure number
\ind{4)} version number

Procedure 0: echo...is the remote program there

Version: allows multiple versions active at same time
\newslide
\centerline{\bbf RPC Semantics}

RPC may select either TCP or UDP

{\bit TCP:} Guarantees correctness of interaction.
\break
Exactly one RPC call is made, exactly one set of parameters
goes in each direction
\break
or an error report is returned.

Operation has high overhead.
\vt
{\bit UDP:} Will attempt the call.
\break
If no response, RPC mechanism retries.
\break
Retry parameters can be set by programmer.

If a response (return value) is received,
\break
at least one call was made
\break
(reply could get lost)

If no response is received,
\break
the server could have received several calls

UDP principle: idempotent
\break
build the client/server so duplicate calls don't cause problems

Lower overhead, but harder to program.
\newslide
\centerline{\bbf RPC Programming Support}

Mutual exclusion: A remote program will accept only one active call 
at a time.

Portmapping:

Problem: TCP/UDP use 16-bit port numbers, RPC 32-bit numbers.
\break
Cannot map RPC numbers onto ports directly.
\break
Solution: RPC programs will obtain port numbers each time they execute.

Implementation: Each machine has an RPC port mapper
that runs at a well-know port.
\break
Portmapper: maintains a database of active port mappings for the RPC programs.
\break
Call the portmapper with program number to get the programs port.
\break
Connect to that port.
\newslide
\centerline{\bbf RPC Message Format}

Call message: header, plus the parameter.

Return message: header, plus the result.

Each message is a single structure (header plus parameter/result).

The entire message must be XDR'd.

RPC knows the structure of the header
\break
so it knows how to XDR the header,
\break
but it must be told how to XDR the parameter/result.

Message content depends on structures used by particular RPC

The header includes:
\break
Message id: used to match reply to call.
\break
Message type: is this a call or reply
\break
RPC version: so you can update RPC itself
\break
Program, procedure and version number: specifying who is being called
\break
Authentication: security and authorization stuff

\newslide
\centerline{\bbf Terminology}

\centerline{Marshaling Arguments}

The arguments/results have to be XDR'd into the (liner/serial) buffer

This is called marshaling.

Receiver has to unmarshal the arguments/results

Marshaling and unmarshaling is done as part of XDRing and unXDRing the
entire message (header plus arguments).
\vt
\centerline{Authentication}

Unix: senders machine, sending user, groups to which sending user belongs

You can use file system permissions to limit what users can do.
\vt
DES (encryption/decryption) is possible for secure channels.

If the receiver doesn't have the key he can't decrypt.

You can use encryption to authenticate the sender.
\break
The sender signs the message,
\break
the receiver can verify the signature.
\newslide
\centerline{\bbf Client/Server Model}

The remote program is a server.
\break
It runs on a ``server" machine.
\break
It receives RPC calls and returns answers.
\vf
The program making RPC calls is a client.

To make a call it must specify
\break
1) which machine the remote program is on
\break
2) which remote program on that machine
\break
3) which procedure in the remote program.

Clients usually call one program, so:

RPC client will:
\break
``connect" to a remote program on a machine
\break
This connect creates a ``handle".

A procedure call will use a ``handle" to specify which program.

Getting TCP rpc handle opens a TCP connection to
the remote program

RPC call: specify handle, procedure, and parameter.
\break
RPC return: specify the result (return to caller).
\bye
