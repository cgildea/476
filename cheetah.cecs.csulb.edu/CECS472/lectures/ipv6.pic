\def\chapternumber{IPv6 -- 21 November 2012 }
\input slides.tex
\centerline{\bbf Internet Protocol Version 6}

The version 6 of the IP protocol is designed to replace the
current version 4 of the protocol.

Notes:

IP Addresses change from 32 bits to 128 bits.

There are backward compatibility features:
\break
1) old addresses translate to new addresses: 96 bits of 0.
\break
2) Dual stack host can send and receive both.
\break
3) Dual stack router can forward both.
\break
4) Dual protocol routers can translate packets from/to IPv4 to/from IPv6

The IPv6 definitions are already available in the {\ltt{}.h} files.

Almost all Linux machines are dual stack.
\break
Activate by assigning IP4 and IP6 addresses.

\newslide
\centerline{\bbf IPv6 structures (in.h)}

The address is 128 bits (was {\ltt{}sin_addr}).
\break
In both versions it is stored inside a struct.
\break
In version 4 it was a long so
the nesting didn't matter.
\break
In version 6 placing the array in a struct
avoids the complications arising from the
fact that arrays are represented by pointers.


{\cprogram
struct in6_addr {
  u_int8_t  s6_addr[16];
}
@endprogram}

%\newslide
%\centerline{\bbf The Version 6 address structure}

In the version6 address structure,
the family and port are the same as before,
just newer type names for the same sizes.
The family will be {\ltt{}AF_INET6}.
\break
The flow information variable is new, exactly how it is to be
used in not fully defined.
\break
The address portion uses the new structure.

{\cprogram
struct sockaddr_in6 {
  u_char          sin6_family;
  u_int16m_t      sin6_port;
  u_int32m_t      sin6_flowinfo;
  struct in6_addr sin6_addr;
};
@endprogram}

There are version 6 values for the constants. ({\ltt{}in.h})

\newslide

Initializing the address structure is similar to version 4.

{\cprogram
struct sockaddr_in6 sin6;
/* Server */
sin6.sin6_family = AF_INET6;
sin6.sin6_flowinfo = 0;
sin6.sin6_port = htons(23);
sin6.sin6_addr = in6addr_any;

/* Client with server on local host */
sin6.sin6_family = AF_INET6;
sin6.sin6_flowinfo = 0;
sin6.sin6_port = htons(23);
sin6.sin6_addr = in6addr_loopback;
@endprogram}


The API calls take version 6 parameters

{\cprogram
s = socket(AF_INET6, SOCK_STREAM, IPPROTO_IPV6);
if (bind(s,(struct sockaddr *)&sin6,sizeof(sin6))<0)
{
  errexit(...);
}
@endprogram}
%\newslide
%\centerline{\bbf Socket Options}

The socket options have version 6 equivalents.

There are a few additional options.

{\cprogram
setsockopt(fd, IPPROTO_IPV6, IPV6_HOPLIMIT,
  &one, sizeof(one));
@endprogram}

\newslide
\centerline{\bbf Names to Numbers}

The system administrator can set up a machines
Domain Name Service so that {\ltt{}gethostbyname}
returns IPv6 addresses.

(Admin Detail) {\ltt{}/etc/resolv.conf}
add the line
\break
{\ltt{}options inet6}

Same call:

{\cprogram
hp = gethostbyname(...);
@endprogram}

Returned structure:
\break
{\ltt{}hp->h_length} will be 16 (was 4)

\vt
Change the memcopy code to use a {\ltt{}sin6}
\vt

{\cprogram
memcpy(&sin6.sin6_addr,hp->h_addr,hp->h_length);
@endprogram}

\vt
Problem: support both IP4 and IP6 addresses

Solution: use {\ltt{}getaddrinfo} instead.

\newslide
\centerline{getaddrinfo}

Designed as a generalization of (and improvement on) gethostbyname/addr
and getservicebyname/port.

The following structure is used by getaddrinfo.
It is used both to specify the nature of the request (IP4, IP6, ...)
and to return the answer.

{\cprogram
struct addrinfo {
 int ai_flags;
 int ai_family;
 int ai_sockettype;
 int ai_protocol;
 int ai_addrlen;
 struct sockaddr *ai_addr;
 char *ai_canonname;
 struct addrinfo *ai_next;
};
@endprogram}

{\ltt{}ai_family}: {\ltt{}AF_INET} or {\ltt{}AF_INET6}
\break
{\ltt{}ai_socktype}: {\ltt{}SOCK_STREAM} or {\ltt{}SOCK_DGRAM}
\break
{\ltt{}ai_protocol}: The protocol to use.
\break
{\ltt{}ai_flags}: control what is returned
\break
{\ltt{}ai_addr}: the address returned
\break
{\ltt{}ai_canonnname}: the fully qualified host name
\break
{\ltt{}ai_next}: because sizes can vary a linked list is returned.

\newslide

{\cprogram
int getaddrinfo(const char *host,
                const char *service,
                const struct addrinfo *hints,
                struct addrinfo **res);
@endprogram}

{\ltt{}host}: The name or IP number of a host.
IP number can be given in IP4 dotted notation, IP6 byte notation
or IP6 mixed notation (see hint).
If this is {\ltt{}NULL}, then the appropriate loop back address will be
returned.

{\ltt{}service}: The name (eg. {\ltt{}"telnet"}) or number (eg. {\ltt{}"7654"})
of a service.
If this is {\ltt{}NULL} the port number in the result will not be initialized.

{\ltt{}hints}: Specifies the type of lookup should be done.

{\ltt{}res}: The information being returned (result).

RETURN value: 0 if no error, otherwise the value is an error code that can
be used with {\ltt{}gai_strerror} to get a string describing the error.

\newslide
\centerline{\bbf Details}

{\ltt{}hints}:
\break
{\ltt{}ai_family} specifies whether a IP4 or IP6 address should be returned.
A value of {\ltt{}AF_UNSPEC} returns either or both (linked list).
\break
{\ltt{}ai_socktype} UDP/TCP, 0 means retrieve all.
\break
{\ltt{}ai_flags} what should be returned
\break
{\ltt{}AI_CANONNAME} return the canonicanical name
\break
{\ltt{}AI_ADDRCONFIG} used with unspec, return only addresses this host is
configured to use.
(Don't return an IPv6 if we have no IPv6 interfaces configured.)

{\ltt{}res}:
\break
This is created by the {\ltt{}getaddrinfo} call.
Consequently it needs to be released using a {\ltt{}freeaddrinfo} call
if you are doing a bunch of get addrs.
The {\ltt{}ai_addr} field is an entire address structure, including
the socket type, port number and address; for the appropriate
family (IP4/6).

A linked of list structures is returned if more than one address
matches the hints.

\newslide

\centerline{\bbf strings to/from addresses}

New calls are needed to turn a string into an address
or an address into a string

String to address:

{\ltt{}inet_pton} Turn a string into an address

{\ltt{}inet_pton(AF_INET6,"::134.139.248.19",&a.sin6_addr);}
\break
{\ltt{}inet_pton(AF_INET6,"::8f8b:f813",&a.sin6_addr);}
\break
The {\ltt{}::} indicates 0's.
\break
{\ltt{}a} must be a {\ltt{}sockaddr_in6}

\vt

Address to string:

{\ltt{}inet_ntop} Turn an address into a string

{\ltt{}inet_ntop(AF_INET6,infoptr->ai_addr,b,sizeof(b));}
\break
{\ltt{}b} should be a character array of size at least
{\ltt{}INET6_ADDRSTRLEN}.

\newslide
\centerline{\bbf Primitive Client}

{\cprogram
int main() {
  int s;
  char message[80];
  struct sockaddr_in6  srv_addr;

  s = socket(PF_INET6, SOCK_STREAM, 0);
  memset(&srv_addr, 0, sizeof(srv_addr));
  inet_pton(AF_INET6,"::134.139.248.19",
    &srv_addr.sin6_addr);
  srv_addr.sin6_family = AF_INET6;
  srv_addr.sin6_port = htons(7654);
  connect(s, (struct sockaddr *) &srv_addr,
    sizeof(srv_addr));
  strcpy(message,"Client speaks");
  write(s, message, 80);
  read(s, message, 80);
  close(s);
  return 1;
}

@endprogram}
\newslide
\centerline{\bbf Primitive Client Notes}

Changes:

1) lots of "6"s

2) used {\ltt{}inet_pton}

\newslide
\centerline{\bbf Primitive Client 2}

{\cprogram
int main() {
  int s;
  char message[80];
  char addr_buf[INET6_ADDRSTRLEN]; /* for ntop */
  struct sockaddr_in6  srv_addr;
  struct addrinfo hint, *infoptr;
  int result;

  hint.ai_family = AF_INET6;
  hint.ai_socktype = SOCK_STREAM;
  hint.ai_protocol = 0; /* any protocol */
  hint.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;
  result = getaddrinfo("puma",NULL,&hint,&infoptr);
  memcpy(&svr_addr,infoptr->ai_addr,
    infoptr->ai_addrlen);
  srv_addr.sin6_port = htons(7654);
  s = socket(PF_INET6, SOCK_STREAM, 0);
  connect(s, (struct sockaddr *) &srv_addr,
    sizeof(srv_addr));
  strcpy(message,"Client speaks");
  write(s, message, 80);
  read(s, message, 80);
  close(s);
  return 1;
}

@endprogram}

\newslide
\centerline{\bbf Primitive Client 2 Notes}

Changes:

1) lots of "6"s

2) used {\ltt{}getaddrinfo}

3) mem copied the entire structure, not just the address part.

Could have:
\break
{\ltt{}getaddrinfo("puma","7654",&hint,&infoptr);}
\break
instead of doing it separately


\newslide
\centerline{\bbf Primitive server}

{\cprogram
int main(){
  int master, client, len; char message[80];
  struct sockaddr_in6 my_addr, his_addr;
  /* get a socket allocated */
  master = socket(PF_INET6, SOCK_STREAM, 0);
  /* bind to the well-known port on our machine */
  memset(&my_addr, 0, sizeof(my_addr));
  my_addr.sin6_family = AF_INET6;
  my_addr.sin6_flowinfo = 0;
  my_addr.sin6_addr = in6addr_any;
  my_addr.sin6_port = htons(7654);
  bind(master, (struct sockaddr *) &my_addr,
    sizeof(my_addr));
  listen(master, 5);
  len=sizeof(his_addr);
  /* get the connection to the client */
  client = accept(master,
    (struct sockaddr *) &his_addr, &len);
    /* get the message from the client */
  read(client,message,80);
  strcpy(message,"Server replies");
  write(client, message, 80); /* send reply */
  close(client);
  close(master);
  return 1;
}

@endprogram}

\newslide
\centerline{\bbf Primitive Server Notes}

Changes:

1) lots of "6"s

2) {\ltt{}in6addr_any}

\bye
