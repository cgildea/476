\def\chapternumber{Chapter 20 --- XDR -- 16 January 2001}
\input slides.tex
\centerline{\bbf Chapter 20}
\centerline{External Data Representation}

Problem: Each computer architecture has its own data representation 

Bad Solution: Asymmetric Data Conversion
\break
Have one side of a client/server pair perform conversion.
Must write a different version of client/server pair 
for each of the architecture pairs

Good Solution: Symmetric Data Conversion
\break
Example: Network Standard Byte Order
\break
Both ends perform conversion

Advantage: Flexibility
\break
Neither machine needs to know about the other's architecture

Disadvantage: 
May perform conversion when it's not necessary

\newslide
\centerline{\bbf External Data Representation (XDR)}

Designed by Sun Microsystems (RFC 1014)
\break
Specifies formats for most data types (Figure 20.2)

{\bit Software Support:}
\break 
library routines to perform conversion

Uses a buffer paradigm to create messages 

Building a message:

1) Allocate a buffer (an XDR stream),
\break
specifies encode/decode

{\ltt{}xdrmem_create} initializes a buffer and
\break
returns a pointer to the start of the stream (buffer)

2) Add items (i.e., fields) one at a time:
\break
Call conversion routines, they
\break
a) encode an object
\break
b) append the encoding to the buffer
\break
c) update the buffer

Result: a stream with XDR format.
\newslide

\newslide
\centerline{\bbf Sending an XDR Message}

Use {\ltt{}write} (TCP) to send the buffer.
\vt
{\bit or...}

You can have XDR conversion routines automatically send data across 
the TCP connection by:

1) Create a socket

2) Call {\ltt{}fdopen} to attach a UNIX standard I/O stream to the socket

3) Use {\ltt{}xdrstdio_create} (instead of {\ltt{}xdrmem_create}) 
to create the XDR stream and connect it 
to the I/O descriptor

4) the conversion routines will
automatically perform a buffered 
write (or read)

Standard I/O library routines can be called (e.g., {\ltt{}fflush})

\newslide
\centerline{\bbf Receiving an XDR Message}

Reverse the entire encoding process

Call {\ltt{}xdrmem_create} to create a buffer and
\break
specify {\ltt{}XDR_DECODE}.

Use standard I/O functions ({\ltt{}read}) to fill the buffer

Call conversion routines to decode the information

Note: if the buffer is created specifying encode,
\break
the conversion routines encode 

if the buffer is created specifying decode,
\break
the conversion routines decode 
\newslide
\centerline{\bbf XDR Details}

The following primitive types can be encoded:

\halign{#\hfil\qquad&#\hfil\cr
bool & {\ltt{}xdr_bool}\cr
char & {\ltt{}xdr_char}\cr
short & {\ltt{}xdr_short}\cr
unsigned short & {\ltt{}xdr_u_short}\cr
int & {\ltt{}xdr_int}\cr
unsigned int & {\ltt{}xdr_u_int}\cr
long & {\ltt{}xdr_long}\cr
unsigned long & {\ltt{}xdr_u_long}\cr
float & {\ltt{}xdr_float}\cr
double & {\ltt{}xdr_double}\cr
void & {\ltt{}xdr_void}\cr
enum & {\ltt{}xdr_enum}\cr}

All unsigned are encoded as unsigned integer.

All signed, character, enum are encoded as integer.

Float, double, void, have special formats.
\newslide
\centerline{\bbf XDR Details}

The following composite types can be encoded.

\halign{#\hfil\quad&#\hfil\cr
fixed-length array&{\ltt{}xdr_vector}\cr
discriminated unions&{\ltt{}xdr_union}\cr
variable-length arrays&{\ltt{}xdr_array}\cr
variable-length byte arrays&{\ltt{}xdr_bytes}\cr
strings&{\ltt{}xdr_string}\cr
variable-length strings&{\ltt{}xdr_wrapstring}\cr
object references&{\ltt{}xdr_reference}\cr
object references&{\ltt{}xdr_pointer}\cr}

Variable-length items have a length integer encode in front of them.

Unions must be discriminated 
(to figure out what types the components have).

{\ltt{}xdr_reference} recursively follows pointers, but doesn't handle
null.

{\ltt{}xdr_pointer} recursively follows pointers and handles
null. Warning: garbage pointers are ``followed".

No xdr exists for multiple dimensional arrays.
\newslide
\centerline{\bbf XDR Example (send)}

Pack up a few integers and send them

{\program
#include <rpc/types.h>
#include <rpc/xdr.h>
#include "connectUDP.c"
main(){
  int sock;
  int test_number_a = 6;
  int test_number_b = 47;
  float test_number_c = -34.5;
  char buffer[80];
  XDR xdrobject;
  XDR *xdrstream = &xdrobject;
  /* XDR a message */
  xdrmem_create(xdrstream, buffer, 80, XDR_ENCODE);
  xdr_int(xdrstream, &test_number_a);
  xdr_int(xdrstream, &test_number_b);
  xdr_float(xdrstream, &test_number_c);
  /* Get a socket (UDP) */ 
  sock = connectUDP("aardvark", "7654");
  /* send the message */
  write(sock, buffer, 80);
  xdr_destroy(xdrstream);
  close(sock);
}
\endprogram}

\newslide
\centerline{\bbf XDR Example (receive)}

Unpack the integers and print them

{\cprogram
#include <rpc/types.h>
#include <rpc/xdr.h>
#include "passiveUDP.c"
main(){
  int sock;
  int test_number_a;
  int test_number_b;
  float test_number_c;
  char buffer[80];
  XDR xdrobject;
  XDR *xdrstream = &xdrobject;
  /* Get a socket (UDP) */ 
  sock = passiveUDP("7654");
  read(sock, buffer, 80);
  close(sock);
  /* extract the message */
  xdrmem_create(xdrstream, buffer, 80, XDR_DECODE);
  xdr_int(xdrstream, &test_number_a);
  xdr_int(xdrstream, &test_number_b);
  xdr_float(xdrstream, &test_number_c);
  printf("%d, %d, %f\n", test_number_a, 
    test_number_b, test_number_c);
  xdr_destroy(xdrstream);
}
@endprogram}
\bye
