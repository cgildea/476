\def\chapternumber{CECS 472, Security  --- Volper -- 13 August 2003}
\input slides.tex
\input cstuff.tex
\centerline{\bbf Network Security}

Principle: Plain text is insecure.
\break
Any machine on any cable can be set to snoop on all passing packets.
\break
Passwords in packets can be read.

Solution:
\break
1) Protect your cable: no DOS, no Apples...
\break
2) Encryption

Symmetric {\bit private key} systems:

One key to encrypt and decrypt.
\break
Both users know the key.
\break
A secure means for sharing a key is needed.
\break
DES, MD5

Asymmetric {\bit public key} systems:

Separate encryption and decryption keys.
\break
Make encryption key public.
\break
RSA, PGP
\vt
Just encrypting a password is insufficient.
\newslide
\centerline{\bbf Authentication}

Establishing a secure session between a client and a server.

Goal: both client and server verify that the other is in possession
of the appropriate authorization.

Uses a 3-way handshake.

Issue encryption keys to client and server ($C$, $S$);
\break
(handshake keys)
\break
possession of these keys constutitutes authorization 

Notation:

$E_C(\ldots)$ encrypt $(\ldots)$ with key $C$
\break
$D_C(\ldots)$ decrypt $(\ldots)$ with key $C$

Note: can use either public or private key encryption. 
\newslide

1) client chooses a random integer $X$.
\break
client sends its ID and $E_C(X)$ to server.

2) server takes client id and looks up $C$ for that client
\break
server computes $D_C()$ and gets $X$
\break
server generates a random number $Y$ 
\break
server sends $E_S(X+1, Y)$ to client.

3) client computes $D_S()$, gets $X+1$, $Y$.
\break
From $X+1$ client knows that server has $C$ and $S$,
\break
hence server is authenticated
\break
client computes $E_C(Y+1)$ and sends to server.

4) server computes $D_C()$, gets $Y+1$
\break
knows that client has $C$ and $S$
\break
hence client is authenticated
\break
server generates a new key $T$
\break
server sends $E_S(T)$ to client.

$T$ is the key to be used for this session
and is used to encrypt all further messages.
\newslide
\newslide
\centerline{\bbf Third Party Authentication}
\centerline{Kerberos}

A trusted third party authenticates.
\break
Each machine has a unique key issued by the trusted host.

1) Client sends clear text request for an {\ltt{}C}--{\ltt{}S} connection to
trusted host.

2) Trusted host generates:
\break
a random number $X$ and a session key $T$ 
\break
sends $E_C(X,T,${\ltt{}S}) and
$E_S(X,T,${\ltt{}C}) to client

3) Client computes $D_C()$ on first part of message,
gets $X,T,${\ltt{}S}
\break
sends $E_T(X,${\ltt{}C}) to server
and second part of message

4) Server computes $D_S()$ on second part of message
\break
gets $X,T,${\ltt{}C}
\break
computes $D_T()$ on first part of message
\break
gets $X,T,${\ltt{}C}
\break
(knows client is valid)
\break
sends $E_T(X+1)$ to client

5) Client computes $D_T()$ gets $X+1$
\break
(knows server is valid)

Rest of session uses key $T$
\newslide
\centerline{\bbf MSN Messenger (example)}

(Similar to the random integer method.)

This protocol uses a ``challenge-response" protocol.

Both server and client know password.

1) server generates a random challenge string

2) client appends password string to challenge string,
computes MD5 hash and sends this as the response.
\vt
Pro: the password doesn't go over the net.

Con: an MD5 hash is not the strongest encryption,
so the password might be learned by watching the
challenge-response pairs.
\bye
