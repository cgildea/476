\def\chapternumber{Chapter 13 --- Iterative Connection-Oriented Server -- 6 January 2004}
\input slides.tex
\centerline{\bbf Chapter 13}
\centerline{Concurrent Single Process Server}

{\bit Motivation:}
If little processing is required per request: 
\break
concurrent servers often behave in a sequential manner
\break
So multiple processes (timesharing) doesn't help.
{\bit Solution:} 
Single-process, concurrent server.
\break
Server watches all connections and handles those with requests.
\break
Less context switching $\Rightarrow$ less CPU

{\bit Idea:}
Use asynchronous I/O to provide apparent concurrency among clients.

{\bit Implementation:} Have a single server process keep TCP
connections open to multiple clients.

{\bbf ALGORITHM 8.5}

\ind{1.} Get the master socket.

\ind{2.} Use select to wait for input on all open sockets.

\ind{3.} Arrival on master socket, open a slave socket.

\ind{4.} Arrival on slave socket, read/write (provide service)

\ind{5.} Repeat 2--4
\newslide
\centerline{\bbf Select Utilities}

{\ltt{}fd} is an integer ({\ltt{}int}).
It is an index into the descriptor table.
This integer array of pointers to file information structures.

{\ltt{}fd_set} is a set of integers.
\break
implemented by a bit vector (array of Booleans).

{\ltt{}FD_SET(fd, &fdset)}: adds a file descriptor ({\ltt{}fd}) to the
set of file descriptors {\ltt{}fdset}.

{\ltt{}FD_CLR(fd, &fdset)}: removed file descriptor from the
set of file descriptors.

{\ltt{}FD_ISSET(fd, &fdset)}: returns TRUE if file descriptor is in
the set of file descriptors.

{\ltt{}FD_ZERO(&fdset)}: the set of file descriptors is set to the empty set

{\ltt{}select(nfds,rfds,wfds,efds,time)}:
Consider only the descriptors {\ltt{}0..nfds-1}.
For each descriptor in the set {\ltt{}*rfds};
if there is input on that descriptor (something to read),
leave the descriptor in the set,
otherwise, remove it.
\break
{\ltt{}rfds} before: we want to know if any of these have input waiting;
after: those that have input waiting.
\newslide
\centerline{\bbf Select Example}

{\cprogram
#include <sys/types.h>
#include <sys/time.h>
#include <sys/file.h>
main (){
  int fd1, fd2; /* two file descriptors */
  fd_set file_set;
  int count;
  fd1 = open("p1.c", 0, O_RDONLY);
  fd2 = open("p2.c", 0, O_RDONLY);
  FD_ZERO(&file_set);
  FD_SET(fd1, &file_set);
  FD_SET(fd2, &file_set);
  FD_SET(0, &file_set); /* stdin */
  count = select(5, &file_set, NULL, NULL, NULL);
  printf("%d, %d\n", fd1, fd2);
  printf("%d\n",count);
  close(fd1);
  close(fd2);
}
3 4
2
@endprogram}

Examines 0,3,4, finds that 3 and 4 can be read

If something is typed: reports ``3" instead of 2

Note: {\ltt{}file_set} is modified by {\ltt{}select}
\newslide
\centerline{\bbf Select}

{\ltt{}ret=select(nfds, rfds, wfds, efds, time);}

{\ltt{}nfds} number of file descriptors

{\ltt{}rfds} check this set for input.
\break
{\ltt{}wfds} check this set to see if output is allowed.
\break
{\ltt{}efds} check this set for errors.
\break
The above are modified: only those with input or output
remain set (others become cleared).

{\ltt{}time} if there is no input (/output), wait this amount of time for
some to occur before returning 0.

Warning: use a copy of the ``{\ltt{}fd_set}" when calling {\ltt{}select}
(because it gets changed).


Read p564 (select) and ``man select" carefully.

\newslide
\centerline{\bbf Detailed analysis}

see Section 13.5 for code.

{\ltt{}rfds}: The set of descriptors that have input pending
\break
{\ltt{}afds}: The set of all open (active) descriptors
\break
{\ltt{}nfds}: The number of file descriptors Unix allows this process

The loops would be more efficient if we kept track of the highest number
descriptor in use, but the code would be more complex.

{\ltt{}FD_ZERO(&afds); FD_SET(msock,&afds)}: initially only the master socket
is open.

{\ltt{}memcpy}: {\ltt{}rfds = afds}, the copy is because {\ltt{}select} will
modify {\ltt{}rfds}

{\ltt{}select}: wait here until there is input on at least one active descriptor
\break
The number active (i.e., what select returns) 
is ignored unless it indicates an error.
\break
The set {\ltt{}rfds} will contain those active descriptors with input waiting.
\break
{\ltt{}msock}: activity on this descriptor means someone has requested
a connect.
\break
Activity on other descriptors means someone already connected has sent a
message.
\newslide
{\ltt{}FD_ISSET(msock...}: if a connect request is waiting, do the accept and
\break
add ({\ltt{}FD_SET}) the new socket descriptor to the active list

{\ltt{}for}: all descriptors
\break
{\ltt{}if (fd...}: only look at slave descriptors with input waiting
\break
{\ltt{}if (echo...}: do an echo on each active slave.
\break
echo returns 0 if it got EOF, in this case
\break
{\ltt{}close} the descriptor and 
remove ({\ltt{}FD_CLR}) the descriptor from the active set

\vf
Detailed descripton of {\ltt{}echo} (page 144):

{\ltt{}cc=read}: we know input is waiting, read it.
\break
{\ltt{}cc < 0}: error
\break
{\ltt{}cc == 0}: eof
\break
{\ltt{}cc > 0}: number of bytes read

{\ltt{}if (cc && write...}: if {\ltt{}cc} is {\ltt{}> 0} then do the write

{\ltt{}return cc}: eof returns 0, otherwise returns a positive

A zero returned here will cause a close of the slave descriptor ({\ltt{}fd})
\newslide
\centerline{\bbf Fairness/Behavior}

If input is waiting from several clients:

The {\ltt{}for} loop will process one request from each client,

No process can be blocked.
\vt
No matter how many requests a client has pending,
\break
the server will only process one per iteration of the while;
\break
along with one request from every other client.

Sending lots of requests will not slow down other clients.
\vt
If several connect requests are pending,
\break
it will take several rounds of the while loop.
\newslide
\centerline{\bbf Sockets and errors}

Old style: return {\ltt{}-1}

New style: for some errors, return {\ltt{}-1}
\break
for reads/writes to a broken/closed socket (or pipe)
\break
raise {\ltt{}SIGPIPE}.

Error handling choices.

1) Write a handler for {\ltt{}SIGPIPE}

{\program
void handler(int x){...}

main(){
  signal(SIGPIPE,handler);
  ...
}
\endprogram}

2) ignore the signal
\break
{\ltt{}signal(SIGPIPE,SIG_IGN);}

3) Use {\ltt{}send}/{\ltt{}recv} in a way that {\ltt{}SIGPIPE} isn't raised.
\newslide
\centerline{\bbf send and recv}

send--similar to write
\break
recv--similar to read

Both have one extra parameter for flags:
\break
The possible flags are:

{\ltt{}MSG_OOB}: process out-of-band data

{\ltt{}MSG_DONTROUTE}: send direct, ignore routing

{\ltt{}MSG_DONTWAIT}: send normally copies the contents
of the message to the system send buffer before proceeding.
If the contents need time to send, the process blocks.
\break
Don't block, return the special value {\ltt{}EAGAIN} ({\ltt{}errno})
\break
A future send will overwrite the buffer losing data.
\break
useful with {\ltt{}select}'s option for ``ready to send"

{\ltt{}MSG_NOSIGNAL}: don't raise SIGPIPE

Example:

{\program
write(sock,buf,sizeof(buf)};
/* With send and flags could become */
send(sock,buf,sizeof(buf),MSG_NOSIGNAL);
\endprogram}
\bye
