\def\chapternumber{Chapter 11 --- Iterative Connection-Oriented Server -- 6 December 2000}
\input slides.tex
\centerline{\bbf Chapter 11}
\centerline{Concurrent Connection-Oriented Server}

Used when: After making a connection,
the client has a long, continuous interaction with the server.
\break
(telnet, rlogin, ftp)

For each client, the master server creates
a separate process (slave server).

Issue: don't forget to shutdown obsolete slave servers
\break
(exit the processes).

Note: run-away client and slave processes are the most common
error in this type of server.

A run-away may consume substantial CPU!
\newslide
\centerline{Detailed Comments}

see Section 11.5 for code.

The base server:

{\ltt{}msock}: master socket
\break
{\ltt{}ssock}: slave socket

{\ltt{}msock=passiveTCP}: get a (1) master socket.

{\ltt{}while (1)}: Handle one client request per iteration

{\ltt{}ssock=accept}: Accept a client,
\break
gets a slave socket connected to that client.

{\ltt{}fork}: generate a slave server process

{\bit Parent process:}

{\ltt{}close(ssock)}: the master server doesn't talk to the client,
\break
so it closes the slave socket.

{\ltt{}break}: master server goes back around the loop to be ready to 
accept another client.
\newslide
{\bit Child Process:}

{\ltt{}close(msock)}: the master socket is used only to accept clients,
\break
the slave server doesn't need, so it closes it.
\break

{\ltt{}TCPechod}: This procedure is the slave server.

{\ltt{}exit()}: When the slave procedure is done, the slave process is done,
\break
exit terminates the slave process
\break
You never get past this!

{\ltt{}while (cc=read...}: Read a ``block" of information from the client

{\ltt{}write(...}: Write the same information back to the client.

Note: segment boundaries are not preserved.

Example: 
Client may write 3, 2000 byte buffers and server may get 2, 1000 byte reads
and a 4000 byte read.

A 0 byte only occurs if the socket at the other end of the connection has
been closed.
\breka
(Otherwise the I/O blocks until something is available.)
\newslide
{\bit Termination:}

Rule: a process delivering a signal must make the delivery before
it can exit.

Notation: a child exiting delivers a signal.

Parent: the parent must receive delivery before the child can exit.
\break
if the parent dies, 
\break
New Unix: {\ltt{}init} (process 1) receives delivery
of any signals and discards them.
\break
Old Unix: the children will become zombies,
waiting (possibly forever) to deliver a signal.
\break
{\ltt{}ps -ux}: processes marked with {\ltt{}Z}

{\ltt{}signal}: When a {\ltt{}SIGCHLD} (child has exited signal)
occurs, interrupt to call {\ltt{}reaper}, then return from interrupt.

reaper--{\ltt{}while}: consumes all pending interrupts in and should exit
when none are pending.
\newslide
\centerline{\bbf Reaper Details

Comer code error: if no {\ltt{}SIGCHLD} interrupts are waiting,
\break
{\ltt{}wait3} returns 0. Comer's code should read
\break
{\ltt{}while (wait3 ...  > 0);} 
\break
The {\ltt{}>=} will cause the program to hang.
\break
(This has been fixed in the shells.)

Old Unix safety:
{\ltt{}case -1: errexit}
\break
Server should close master socket
then wait until all children have exited.

\vt
What happens with no reaper.
\break
No one receives the children exit signals
\break
children don't exit
\break
You run out of processes
\break
Message: cannot fork, out of processes

Problem: You can't do a ``ps" to see this (you're out of processes and
ps is a process).

Problem: When you kill the parent, {\ltt{}init} handles all the children
exit signals, so they go away (before you get a chance to do a ps).
\newslide
\centerline{\bbf Graceful Termination}

If you close and the other process has just done a write,
\break
that write will fail.

Good behavior:
\break
1) annonce you are leaving.

2) consume any pending input.

3) exit.

{\ltt{}shutdown}: a partial close of a socket. You can shutdown output, input
or both.

output: the other process will see end of file.
\break
input: any writes by the other process will fail.
\break
both: a close

Style: 
\break
1) shutdown output (announcing you are done)

2) read anything in the socket from the other processes (until end of file)

3) close/exit
\bye
