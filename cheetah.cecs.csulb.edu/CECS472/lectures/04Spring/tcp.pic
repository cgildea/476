\def\chapternumber{CECS 472, TCP --- Volper -- 29 January 1997}
\input slides.tex
\input cstuff.tex
\centerline{\bbf Transmission Control Protocol --- TCP}
%Comer: Volume I, Chapters 5, 8

Goal: Reliable delivery of a stream (long message).

Goal: Bidirectional.

Establish a connection (destination).

Break the message into segments (packets).

Ensure everything gets to the destination.

Problems:
\ind{}Segments get lost.
\ind{}Segments get delayed.
\ind{}Segments get duplicated.
\ind{}Segments get damaged.

Principle: 
\ind{}Number the Segments.
\ind{}Receiver: Acknowledge what was received.
\ind{}Sender: Keep track of sent and acknowledged.
\ind{}Sender: Resend lost segments.
\newslide
\centerline{\bbf Acknowledgements}

On Connection: 
\break
1) Server: Listen
\break
2) Client: Connect request
\break
3) Server: Connect acknowledge (confirms connection)
\break
4) Client: gets acknowledge (confirms connection)
\vt
On transmission:

Consideration: Waiting for acknowledgement before sending next packet is too
slow.

Solution: Several segments in transmission at once
{\bit sliding windows}.
\break
Implementation: $n$ octets (bytes) in transmission at once.
\break
Number of segments depends on segment size.

Example $n=4096$, segment size = 512
\break
(max with an IP size of 576 is  536)
\break
1) Transmit the first 8 segments.
\break
2) Send segments 9 when packet 1 is acknowledged.
\break
3) Send segments $j$ when all segments $\le j-8$ are acknowledged.
\newslide
\centerline{\bbf TCP Segment Details}

{\program
/* TCP header.  Per RFC 793, Sept, 1981. */
struct tcphdr {
  u_short th_sport;    /* source port */
  u_short th_dport;    /* destination port */
  tcp_seq th_seq;      /* sequence number */
  tcp_seq th_ack;      /* acknowledgement number */
  u_char  th_off:4;    /* data offset */
  u_char  th_flags;  /* FIN SYN RST PUSH ACK URG */
  u_short th_win;      /* window */
  u_short th_sum;      /* checksum */
  u_short th_urp;      /* urgent pointer */
};
\endprogram}

{\bit Port numbers:}
\break
{\bit Sequence number:} data packet being sent (sender)
\break
{\bit Acknowledgement:} receiver acknowledges receiving packet
\break
{\bit Window:} receiver can adjust window size.
\break
(Sender need not use full size.)
\break
{\bit Flags:} finished, please synchronize sequence number (I'm lost),
reset (let's start sequence numbers over), acknowledgement (no data),
urgent (deliver immediately regardless of position in sequence
\break
{\bit Offset:} packet was fragmented.

\newslide
\centerline{\bbf Example}

Window size = 2048, segment size = 512

a) Sender: send segment 1, sequence = 0
\break
b) Sender: send segment 2, sequence = 512
\break
c) Sender: send segment 3, sequence = 2*512
\break
d) Sender: send segment 4, sequence = 3*512
\break
e) Receiver: gets segment 3
\break
f) Receiver: gets segment 2
\break
g) Receiver: gets segment 1
\break
h) Receiver: sends segment with
\break
acknowledge = 3*512; (next expected)
\break
window = 1024 (slow down)
\break
i) Receiver: gets segment 4 
\break
j) Receiver: sends acknowledge = 4*512
\break
k) Sender: gets acknowledgement 3*512 (window 1024)
\break
l) Sender: send segment 5, sequence = 4*512
\break
m) Sender: gets acknowledgement 4*512 
\break
n) Sender: send segment 6, sequence = 5*512
\break
o) Receiver: gets segment 5 
\break
p) Receiver: sends acknowledge = 5*512
\break
window = 2048 (speed up)
\break
q) Sender: gets acknowledgement 5*512, window 2048
\break
r) Sender can now send 7, 8, 9

\newslide
\centerline{\bbf Retransmission}

Crucial: How do you know a segment was lost.
\break
Answer: No acknowledgement. How long to wait?
\break
Side issue: Acknowledgements can get lost.

Too short wait = extra retransmission.
\break
Receiver gets duplicate segment.
\break
Receiver must acknowledge (in case due to lost ack).
\break
Damage: ``clogs" net.

Process: Sender estimates round trip time ($RTT$).
\break
Use weighted average of recent acknowledgements.
\break
$\overline{RTT} = \alpha * \overline{RTT} + \beta * RTT$
\break
usually $\beta = 1 - \alpha$

Retransmit time: a function of $RTT$.
\break
Example: $3*\overline{RTT}$
\break
Adapt retransmit time.
\break
Double for each retransmit.
\break
Reset to function of $\overline{RTT}$ for each ack.

Problem: long RTTs vary dramatically.
\break
Compute Standard Deviation (of recent)
\break
Use \quad $\overline{RTT} + 2 * \sigma$

Ignore retransmissions when computing RTT.
\newslide
\centerline{\bbf Congestion}

Problem: causes lost segments.

Solution: less traffic.

Sender: assumes potential congestion
\break
Sender: assumes retransmission means congestion

Traffic is the number of segments in transmission (i.e., window size).

1) Retransmission: 
\break
Sender temporarily shrinks the window size.
\break
Sender temporarily increases retransmit time.

Halve window size
\break
Double retransmit time

2) Clear acknowledge (no retransmit required)
\break
Sender increase the window size by 1.
\break
Sender decrease retransmit time.

Never exceed base values.

3) Slow start:
\break
Sender uses initial (shrunk) window size of 1.
\newslide
\centerline{\bbf Slow Start Example}

a) Sender sends segment 1
\break
b) Sender gets acknowledgment for segment 1
\break
c) Sender sends segments 2--3 (2)
\break
d) Sender gets acknowledgment for segments 2--3
\break
e) Sender sends segments 4--7 (4)
\break
f) Sender gets acknowledgment for segments 4--7
\break
g) Sender sends segments 8--15 (8)
\break
h) Sender gets acknowledgment for segments 8--15

Note: increase of 1 per acknowledged segment yields doubling effect.
\bye
