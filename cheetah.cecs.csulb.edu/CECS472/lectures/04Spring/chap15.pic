\def\chapternumber{Chapter 15 --- Multiple Service Servers -- 23 August 2002}
\input slides.tex
\centerline{\bbf Chapter 15}
\centerline{Multiple Service Servers}

{\bit Outline:}
\ind{}Motivation
\ind{}Iterative, Connectionless Server.
\ind{}Concurrent, Connection-Oriented Server.
\ind{}Single-Process Server
\ind{}Flexibility of Invoking Separate Programs
\ind{}Multiservice, Multiprotocol Designs
\ind{}Example Multiservice Server
\ind{}BSD super server: inetd
\newslide

{\bit Motivation:}

Consolidation of servers reduces:  
\break
--the number of executing processes
\break
--the total code required

Principle: use a separate socket (and port) for each service, 
but have one program handle them all.

Otherwise similar to the corresponding single service Server.

{\bit Iterative, Connectionless, Multiservice Server}
\ind{1}  Opens a set of UDP sockets.
\ind{2}  Binds each one to a well-known port for one of the
services being offered.
\ind{3} A table maps services to sockets (for each
descriptor, the table records the address of a procedure 
to call for service).
\ind{4}  Call select to wait for a datagram to arrive.
\ind{5}  Examine the descriptor and call the appropriate service procedure.
\ind{6}  Return to the select call.
\newslide

Iterative is good for handling short, non-interactive services.

{\bit  Iterative, Connection-Oriented, Multiservice Server}
\ind{1} Opens one socket for each service and binds each one to
the appropriate well-known port.
\ind{2} A table maps services to sockets (for each
descriptor, the table records the address of a procedure 
\ind{3} Calls select to wait for an incoming connection request.
\ind{4}  When a request arrives, calls accept to create a new
socket for the incoming connection.
\ind{5} Uses the new socket to interact with the client, then closes
the socket.
\ind{6}  Return to the select call.

\newslide
{\bit Concurrent, Connection-Oriented, Single-Process Multiservice Server}
\ind{1} Opens one master socket for each service and binds each one to
the appropriate well-known port.
\ind{2} A table maps services to sockets (for each
descriptor, the table records the address of a procedure 
\ind{3} Calls select to wait for incoming connection requests master sockets
or incoming data to read on slave sockets.
\ind{4a}  For connect requests, calls {\ltt{}accept} to create a new
socket for the incoming connection.
\ind{4b}  For incoming data, calls the appropriate procedure to provide service.
\ind{5}  Return to the select call.

\newslide
{\bit Concurrent, Connection-Oriented, Multi-Process Multiservice Server}

\ind{1} Opens one master socket for each service and binds each one to
the appropriate well-known port.
\ind{2} A table maps services to sockets (for each
descriptor, the table records the address of a procedure 
\ind{3} Calls select to wait for incoming connection requests.
\ind{4}  Creates a slave processes for each new connection.
\ind{5}  Each slave handles service for client.

\vt
{\bit Software Design}

Break code into independent components using
separately compliled programs.
\break
Compile those modules which change and relink.

Multi-process Servers: {\ltt{}fork}/{\ltt{}exec} allow call of a separately
compiled (and maintained program).
\newslide
\centerline{\bbf Example Multiservice Server}

see Section 15.9 for code

Four services: echo, chargen, daytime, and time

{\program
struct service{
  char *sv_name;      /* ASCII name of service */
  char sv_useTCP;     /* 0=UDP 1=TCP           */
  int sv_sock;        /* socket descriptor     */
  int (*sv_func)(int);/* function to call      */
}
\endprogram}

{\ltt{}svent} is an array of 4 of these
\break
Each entry is used to store the information about one of the services.
\break
C note: {\ltt{}sv_func} stores the address of a function.
\break
function calls are by address
\break
{\ltt{}svent[3]->sv_func(4)}
will call the function whose address is found in the 4th record 
({\ltt{}TCPtimed}), and ask it to use the socket found in descriptor 4.
\break
{\ltt{}svent[3]->sv_sock} is the master socket for the service

Array {\ltt{}fd2sv} to map from the descriptor back to
an entry in svent (reverse map).
%\break
%Ex: if {\ltt{}daytime} was {\ltt{}passiveTCP}'d to socket 6,
%then {\ltt{}fd2sv[6]} gets a {\ltt{}2}
%\break
%({\ltt{}daytime} is at position 2 in the {\ltt{}svent} array)
\newslide
\centerline{Structure Before socket allocation}

\vt
{\railroadfont
.PS
entryht = 0.25i
entrywd = 1.4i
codeht = 1.0i
codewd = 1.0i
sockht = 0.3i
sockwid = 0.3i
# svent
# parameters: Id, where, service name, TCP/UDP, Socket, function pointer
  define svent X
    move right to $2 + (0, -2*entryht)
    $1:
    [
      Main:  box wid entrywd ht 4*entryht with .nw at $2
      Name:  box wid entrywd ht entryht $3 with .n at Main.n
      Tcp:   box wid entrywd ht entryht $4 with .n at Name.s
      Sock:  box wid entrywd ht entryht $5 with .n at Tcp.s
      Func:  box wid entrywd ht entryht with .n at Sock.s
    ] 
    move right to $1 X

# end svent

Servs: box wid entrywd ht 16*entryht
svent(Eentry, Servs.nw, "echo", "TCPSERV", "NOSOCK", Acode.w)
move to 1/4 between Servs.nw and Servs.sw
Chstart: Here
svent(Centry, Chstart.nw, "chargen", "TCPSERV", "NOSOCK", Acode.w)
move to 1/2 between Servs.nw and Servs.sw
Daystart: Here
svent(Dentry, Daystart, "daytime", "TCPSERV", "NOSOCK", Acode.w)
move to 3/4 between Servs.nw and Servs.sw
Timstart: Here
svent(Tentry, Timstart, "time", "TCPSERV", "NOSOCK", Acode.w)
Ecode: box wid codewd ht codeht with .nw at Servs.ne + (1.5i, -0.5i) "echo()" "function" "code"
Ccode: box wid codewd ht codeht with .n at Ecode.s "chargen()" "function" "code"
Dcode: box wid codewd ht codeht with .n at Ccode.s "daytime()" "function" "code"
Tcode: box wid codewd ht codeht with .n at Dcode.s "time()" "function" "code"
arrow from Eentry.Func.c to Ecode.nw
arrow from Centry.Func.c to Ccode.nw
arrow from Dentry.Func.c to Dcode.nw
arrow from Tentry.Func.c to Tcode.nw
"svent" at Servs.n above
Sockets: box wid sockwid ht 8*sockht with .e at Servs.w + (-1.0i, 0)
"fd2sv" at Sockets.n above
Aa: box wid sockwid ht sockht with .n at Sockets.n "?"
"0 " at Aa.w rjust
Ab: box wid sockwid ht sockht with .n at last box.s "?"
"1 " at Ab.w rjust
Ac: box wid sockwid ht sockht with .n at last box.s "?"
"2 " at Ac.w rjust
Ad: box wid sockwid ht sockht with .n at last box.s "?"
"3 " at Ad.w rjust
Ae: box wid sockwid ht sockht with .n at last box.s "?"
"4 " at Ae.w rjust
Af: box wid sockwid ht sockht with .n at last box.s "?"
"5 " at Af.w rjust
Ag: box wid sockwid ht sockht with .n at last box.s "?"
"6 " at Ag.w rjust
Ah: box wid sockwid ht sockht with .n at last box.s "?"
"7 " at Ah.w rjust
.PE
\centerline{\box\graph}}

Strings are for human interface purposes.

No sockets are entered (yet)
\break
0,1,2: are {\ltt{}stdin}, {\ltt{}stdout} and {\ltt{}stderr} and will be unused
\newslide
\centerline{Structure after socket allocation}

\vt
{\railroadfont
.PS
entryht = 0.25i
entrywd = 1.4i
codeht = 1.0i
codewd = 1.0i
sockht = 0.3i
sockwid = 0.3i
# svent
# parameters: Id, where, service name, TCP/UDP, Socket, function pointer
  define svent X
    move right to $2 + (0, -2*entryht)
    $1:
    [
      Main:  box wid entrywd ht 4*entryht with .nw at $2
      Name:  box wid entrywd ht entryht $3 with .n at Main.n
      Tcp:   box wid entrywd ht entryht $4 with .n at Name.s
      Sock:  box wid entrywd ht entryht $5 with .n at Tcp.s
      Func:  box wid entrywd ht entryht with .n at Sock.s
    ] 
    move right to $1 X

# end svent

Servs: box wid entrywd ht 16*entryht
svent(Eentry, Servs.nw, "echo", "TCPSERV", "3", Acode.w)
move to 1/4 between Servs.nw and Servs.sw
Chstart: Here
svent(Centry, Chstart.nw, "chargen", "TCPSERV", "4", Acode.w)
move to 1/2 between Servs.nw and Servs.sw
Daystart: Here
svent(Dentry, Daystart, "daytime", "TCPSERV", "5", Acode.w)
move to 3/4 between Servs.nw and Servs.sw
Timstart: Here
svent(Tentry, Timstart, "time", "TCPSERV", "6", Acode.w)
Ecode: box wid codewd ht codeht with .nw at Servs.ne + (1.5i, -0.5i) "echo()" "function" "code"
Ccode: box wid codewd ht codeht with .n at Ecode.s "chargen()" "function" "code"
Dcode: box wid codewd ht codeht with .n at Ccode.s "daytime()" "function" "code"
Tcode: box wid codewd ht codeht with .n at Dcode.s "time()" "function" "code"
arrow from Eentry.Func.c to Ecode.nw
arrow from Centry.Func.c to Ccode.nw
arrow from Dentry.Func.c to Dcode.nw
arrow from Tentry.Func.c to Tcode.nw
"svent" at Servs.n above
Sockets: box wid sockwid ht 8*sockht with .e at Servs.w + (-1.0i, 0)
"fd2sv" at Sockets.n above
Aa: box wid sockwid ht sockht with .n at Sockets.n "?"
"0 " at Aa.w rjust
Ab: box wid sockwid ht sockht with .n at last box.s "?"
"1 " at Ab.w rjust
Ac: box wid sockwid ht sockht with .n at last box.s "?"
"2 " at Ac.w rjust
Ad: box wid sockwid ht sockht with .n at last box.s
"3 " at Ad.w rjust
Ae: box wid sockwid ht sockht with .n at last box.s
"4 " at Ae.w rjust
Af: box wid sockwid ht sockht with .n at last box.s
"5 " at Af.w rjust
Ag: box wid sockwid ht sockht with .n at last box.s
"6 " at Ag.w rjust
Ah: box wid sockwid ht sockht with .n at last box.s "?"
"7 " at Ah.w rjust
arrow from Ad.c to Eentry.nw
arrow from Ae.c to Centry.nw
arrow from Af.c to Dentry.nw
arrow from Ag.c to Tentry.nw
.PE
\centerline{\box\graph}}

\newslide
see Section 15.9 for code

{\ltt{}for}: go through the array of services and fill in the socket numbers.
\break
a 0 for the name indicates the end of the array
\break
(C doesn't have array attributes)

Open either a TCP master socket or
\break
a UDP socket for each service.

{\ltt{}while(1)} the main service loop,

{\ltt{}memcpy...select}: wait for a connect/message
\break
{\ltt{}EINTR}: (control-C) is ignored

{\ltt{}for} process each connect/message
\break
Use the reverse map ({\ltt{}fd2sv}) to find the service entry information
\break
UDP, just call the service function,
\break
TCP, (call doTCP) set up a slave socket, then fork a child that
calls the service function

The service function must be correctly pre-programmed to
do TCP (read/write) or UDP (receive/send).
\newslide
\centerline{\bbf inetd}

BSD UNIX super server

\ind{} Supplies many small TCP/IP services
\ind{} Services can be added to (deleted from) inetd using a configuration file

{\ltt{}/etc/inetd.conf} the config file

Service name--such as {\ltt{}telnet}

Socket type--{\ltt{}dgram}/{\ltt{}stream}

Service type--{\ltt{}udp}/{\ltt{}tcp}

wait/nowait--single process/multiprocess (fork)

user--privilege level (actually user name)

service procedure--name of the executable file, internal indicates
a tiny service like time provided directly by inetd.

display name--what to show to {\ltt{}ps}
\vt
Only one server is running waiting for many things.

Specific servers are not started unless needed.
\bye
