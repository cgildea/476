\def\chapternumber{Chapter 13 --- Iterative Connection-Oriented Server -- 29 November 2010}
\input slides.tex
\centerline{\bbf Chapter 13}
\centerline{Concurrent Single Process Server}

{\bit Motivation:}
If little processing is required per request: 
\break
concurrent servers often behave in a sequential manner
\break
So multiple processes (timesharing) doesn't help.
{\bit Solution:} 
Single-process, concurrent server.
\break
Server watches all connections and handles those with requests.
\break
Less context switching $\Rightarrow$ less CPU

{\bit Idea:}
Use asynchronous I/O to provide apparent concurrency among clients.

{\bit Implementation:} Have a single server process keep TCP
connections open to multiple clients.

{\bbf ALGORITHM 8.5}

\ind{1.} Get the master socket.

\ind{2.} Use select to wait for input on all open sockets.

\ind{3.} Arrival on master socket, open a slave socket.

\ind{4.} Arrival on slave socket, read/write (provide service)

\ind{5.} Repeat 2--4
\newslide
\centerline{\bbf Select Utilities}

{\ltt{}fd} is an integer ({\ltt{}int}).
It is an index into the descriptor table.
This integer array of pointers to file information structures.

{\ltt{}fd_set} is a set of integers.
\break
implemented by a bit vector (array of Booleans).

{\ltt{}FD_SET(fd, &fdset)}: adds a file descriptor ({\ltt{}fd}) to the
set of file descriptors {\ltt{}fdset}.

{\ltt{}FD_CLR(fd, &fdset)}: removed file descriptor from the
set of file descriptors.

{\ltt{}FD_ISSET(fd, &fdset)}: returns TRUE if file descriptor is in
the set of file descriptors.

{\ltt{}FD_ZERO(&fdset)}: the set of file descriptors is set to the empty set

{\ltt{}select(nfds,rfds,wfds,efds,time)}:
Consider only the descriptors {\ltt{}0..nfds-1}.
For each descriptor in the set {\ltt{}*rfds};
if there is input on that descriptor (something to read),
leave the descriptor in the set,
otherwise, remove it.
\break
{\ltt{}rfds} before: we want to know if any of these have input waiting;
after: those that have input waiting.
\newslide
\centerline{\bbf Select Example}

{\cprogram
#include <sys/types.h>
#include <sys/time.h>
#include <sys/file.h>
main (){
  int fd1, fd2; /* two file descriptors */
  fd_set file_set;
  int count;
  fd1 = open("p1.c", 0, O_RDONLY);
  fd2 = open("p2.c", 0, O_RDONLY);
  FD_ZERO(&file_set);
  FD_SET(fd1, &file_set);
  FD_SET(fd2, &file_set);
  FD_SET(0, &file_set); /* stdin */
  count = select(5, &file_set, NULL, NULL, NULL);
  printf("%d, %d\n", fd1, fd2);
  printf("%d\n",count);
  close(fd1);
  close(fd2);
}
3 4
2
@endprogram}

Examines 0,3,4, finds that 3 and 4 can be read

If something is typed: reports ``3" instead of 2

Note: {\ltt{}file_set} is modified by {\ltt{}select}
\newslide
\centerline{\bbf Select}

{\ltt{}ret=select(nfds, rfds, wfds, efds, time);}

{\ltt{}nfds} number of file descriptors

{\ltt{}rfds} check this set for input.
\break
{\ltt{}wfds} check this set to see if output is allowed.
\break
{\ltt{}efds} check this set for errors.
\break
The above are modified: only those with input or output
remain set (others become cleared).

{\ltt{}time} if there is no input (/output), wait this amount of time for
some to occur before returning 0.

Warning: use a copy of the ``{\ltt{}fd_set}" when calling {\ltt{}select}
(because it gets changed).


Both the textbook entry for select (Appendix 1) and ``man select" 
need to be read carefully.

\newslide
\centerline{\bbf Detailed analysis}

see Section 13.5 for code.

{\cprogram
int main(int argc, char* argv[]){
  char *service="echo";
  struct sockaddr_in fsin;
  int msock;
  fd_set rfds;
  fd_set afds;
  unsigned int alen;
  int fd,nfds;
  switch (argc) {
   ...
  }
@endprogram}

{\ltt{}rfds}: The set of descriptors that have input pending
\break
{\ltt{}afds}: The set of all open (active) descriptors
\break
{\ltt{}nfds}: The number of file descriptors Unix allows this process

All other code here, including the switch is identical to previous servers.

\newslide
{\cprogram
msock=passiveTCP(service,QLEN);
nfds=getdtablesize();
FD_ZERO(&afds);
FD_SET(msock,&afds);
while(1) {
@endprogram}

{\ltt{}getdtablesize}: this Unix system call returns the maximum number of
descriptors in the descriptor table. They will be numbered 0..nfds-1.
The loops generally go through all possible descriptors.
The loops would be more efficient if we kept track of the highest number
descriptor in use, but the code would be more complex.

{\ltt{}FD_ZERO}: Initialized the set of active file descriptors to be empty,

{\ltt{}FD_SET}: Initially the master socket (only) is open, so we
put it into the descriptor set.

The service loop is standard {\ltt{}while(1)}

\newslide
\centerline{Inside service loop 1}

{\cprogram
memcpy(&rfds,&afds,sizeof(rfds));
if (select(nfds,&rfds,NULL,NULL,NULL)<0)
  errexit(...);
@endprogram}

{\ltt{}memcpy}: what is in {\ltt{}afds} is copied into
{\ltt{}rfds}. Because {\ltt{}select} modifies the sets it is passed
we need to pass a copy and not the original to it.

{\ltt{}select}: The program waits here until there is input on at least one
descriptor in the {\ltt{}rfds} set.

The last parameter is {\ltt{}NULL} indicating that this wait will never
time out.

The number of discriptors with input waiting (i.e., what select returns) 
is ignored unless it indicates an error.

The set {\ltt{}rfds} will contain those active descriptors with input waiting.

\newslide
\centerline{Inside service loop 2}

{\cprogram
if (FD_ISSET(msock,&rfds)) {
  int ssock;
  alen=sizeof(fsin);
  ssock=accept(msock,
    (struct sockaddr *)&fsin,&alen);
  if (ssock<0)
    errexit(...);
  FD_SET(ssock,&afds);
}
@endprogram}

The first check is to see if the master socket is set.

Activity on the {\ltt{}msock} descriptor means someone has requested
a connect.
\break
Activity on other descriptors means someone already connected has sent a
message.

{\ltt{}if (FD_ISSET(msock...}: if a connect request is waiting,
do the standard accept and
\break
use ({\ltt{}FD_SET}) to add the new socket descriptor to the list
of active descriptors.

Because there may be more than one descriptor active, we need to
continue with the tests.
We are not yet ready to go back to the accept.
\newslide
\centerline{Inside service loop 3}

{\cprogram
for (fd=0;fd<nfds;++fd)
  if (fd!=msock && FD_ISSET(fd,&rfds))
    if (echo(fd)==0) {
      (void) close(fd);
      FD_CLR(fd,&afds);
    }
@endprogram}

If there is activity on any of the slave sockets, it is an echo request.
In this case we do the echo.

The {\ltt{}for} goes through all possible descriptors
\break
{\ltt{}if}: 
\break
{\ltt{}fd!=msock}: do not consider the master socket, that was already
handled.
\bresk
{\ltt{}FD_SET(fd,&rfds)}: Does the (slave) socket have input waiting.

{\ltt{}echo(fd)}: do an echo on each slave descriptor with input waiting.

{\ltt{}if (echo...} the recall will return 0 if it got EOF.
An EOF means the client has exited; so we won't be talking to that
client again. 
\break
So we {\ltt{}close} the descriptor and 
remove ({\ltt{}FD_CLR}) the descriptor from the active set
(Notice the {\ltt{}afds} here!)

\newslide
Detailed descripton of the {\ltt{}echo} procedure:

{\cprogram
int echo(int fd){
  char buf[BUFSIZ];
  int cc;
  cc=read(fd,buf,sizeof buf);
  if (cc<0) errexit(...);
  if (cc && write(fd,buf,cc)<0)
    errexit(...);
  return cc;
}
@endprogram}

{\ltt{}buf}: a real buffer to read into.

{\ltt{}BUFSIZ}: he meant {\ltt{}BUFSIZE};
but it happens a system variable (without the E) has the
value {\ltt{}4096}.

{\ltt{}cc=read}: we know input is waiting, read it. Three cases.

{\ltt{}cc < 0}: A read error has occurred. The error exit is bad here.
One bad read from a crashed client brings down the whole server.
A {\ltt{}return 0;} would be better, that would cause the socket
to be closed and the entry for the crashed client to be removed
from the {\ltt{}afds} list.

{\ltt{}cc == 0}: means a normal eof, that is, the client did a normal
shutdown. The code will cause us to return this value.
A return of 0, makes the main program close the socket and remove
this clients entry from the {\ltt{}afds}.

{\ltt{}cc > 0}: In this case this is the number of bytes read
we want do do an echo of what we have just read.

{\ltt{}if (cc && write...}: if {\ltt{}cc} is {\ltt{}> 0} then do the write
\break
if {\ltt{}write} fails ({\ltt{}< 0)}), crash the server.
This is bad, a {\ltt{}return 0;} would be better here.

{\ltt{}return cc}: In the case of eof {\ltt{}cc} is 0, {\ltt{}cc}
is the number bytes read (which is a positive number)

%A zero returned here will cause a close of the slave descriptor ({\ltt{}fd})
\newslide
\centerline{\bbf Fairness/Behavior}

If input is waiting from several clients:

The {\ltt{}for} loop will process one request from each client,

No process can be blocked by other processes.
\vt
No matter how many requests a client has pending,
\break
the server will only process one request per iteration of the while;

It will also process one request from every other client that
has requests waiting.

Sending lots of requests will not slow down other clients.
\vt
If several connect requests are pending,
\break
it will take several rounds of the while loop.
\newslide
\centerline{\bbf Sockets and errors}

Old style: return {\ltt{}-1}

New style: for some errors, return {\ltt{}-1}
\break
for reads/writes to a broken/closed socket (or pipe)
\break
raise {\ltt{}SIGPIPE}.

Error handling choices.

1) Write a handler for {\ltt{}SIGPIPE}

{\program
void handler(int x){...}

main(){
  signal(SIGPIPE,handler);
  ...
}
\endprogram}

2) ignore the signal
\break
{\ltt{}signal(SIGPIPE,SIG_IGN);}

3) Use {\ltt{}send}/{\ltt{}recv} in a way that {\ltt{}SIGPIPE} isn't raised.
\newslide
\centerline{\bbf send and recv}

send--similar to write
\break
recv--similar to read

Both have one extra parameter for flags:
\break
The possible flags are:

{\ltt{}MSG_OOB}: process out-of-band data

{\ltt{}MSG_DONTROUTE}: send direct, ignore routing

{\ltt{}MSG_DONTWAIT}: send normally copies the contents
of the message to the system send buffer before proceeding.
If the contents need time to send, the process blocks.
\break
Don't block, return the special value {\ltt{}EAGAIN} ({\ltt{}errno})
\break
A future send will overwrite the buffer losing data.
\break
useful with {\ltt{}select}'s option for ``ready to send"

{\ltt{}MSG_NOSIGNAL}: don't raise SIGPIPE

Example:

{\program
write(sock,buf,sizeof(buf)};
/* With send and flags could become */
send(sock,buf,sizeof(buf),MSG_NOSIGNAL);
\endprogram}
\bye
