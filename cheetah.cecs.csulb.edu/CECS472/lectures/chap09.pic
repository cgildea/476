\def\chapternumber{Chapter 9 --- Iterative Connectionless Server -- 22 April 2010}
\input slides.tex
\centerline{\bbf Chapter 9}
\centerline{Iterative Connectionless Server}

{\ltt{}passiveUDP(const char *service);}
\break
set up a UDP server socket
\break
parameter: name/port number of service
\break
{\ltt{}return passivesock(service,"udp",5); }
\vt
{\cprogram
int passivesock(const char* service,
       const char* transport, int qlen)
@endprogram}

Can do TCP or UDP (transport)

\ind{--}server waits for a connection (TCP) or
message (UDP) on this socket.
\ind{--}this will be the ``well-known port" to which the client tries to connect (TCP)
or send a message (UDP).

parameters: 
\break
name or port number of the service
\break
tcp/udp indicator
\break
{\ltt{}qlen} ignored on UDP sockets

This socket can be used by iterative or concurrent servers

\newslide
\centerline{passivesock}
\centerline{Detailed Comments}

see Section 9.2 for code

{\cprogram
struct servent *pse;
struct protent *ppe;
struct sockaddr_in sin;
int s, type;
@endprogram}

{\ltt{}pse} and {\ltt{}ppe} are used in setting up the {\ltt{}sin}
structure.
\break
The {\ltt{}sin} structure will be used for the {\ltt{}bind}.
\break
{\ltt{}s} will be our socket
\break
{\ltt{}type} will be {\ltt{}IPPROTO_UDP} (in our case)

{\cprogram
memset(&sin,0,sizeof(sin));
sin.sin_family=AF_INET;
sin.sin_addr.s_addr=INADDR_ANY;
@endprogram}

Initialize the internet address structure.
\break
Our protocol (family) is always {\ltt{}AF_INET}.

The {\ltt{}INADDR_ANY} says we are not doing any firewall stuff.
Running on a host that is a gateway 
(a machine with several internet interfaces).
\break
Each interface will have its own internet address.
\break
This server will accept messages/connections
on any internet address that belongs to the host.
\break
This also allows us to move the server software to another host with no changes.
\newslide
{\ltt{}if (pse=getservbyname(service,transport))}
\break
We will take two guesses, this is guess 1:
\break
it is the name of a service (like {\ltt{}"telnet"}).
\break
if guess one is successful we go to the ``then"
\break
if it fails we go to the ``else"

{\cprogram
sin.sin_port =
      htons(ntohs((u_short)pse->s_port)+portbase);
@endprogram}

Guess 1 worked, extract the port number from the service entry structure

With {\ltt{}portbase==0} the math does nothing.

Ports below 1000 are reserved (root access only)---
\break
this math allows us to add an offset ({\ltt{}portbase})
so non-systems types can build client/server programs
that use names such as {\ltt{}telnet}.

If {\ltt{}portbase==2000} then {\ltt{}telnet} would evaluate
to 2023.

Math:
convert to an integer, add the base, convert back to network standard
\newslide
Guess 2: it is a port number (like {\ltt{}"2345"}).

{\cprogram
else if
((sin.sin_port=htons((u_short)atoi(service)))==0)
  errexit("....");
@endprogram}

This is the same format we saw in the client for guessing that
it was a port number.

Try to convert the string to an integer {\ltt{}atoi}
\break
put that integer into network standard order.
\break
On failure {\ltt{}atoi} returns 0, which takes you
to the error exit.

\vt
Note that gethostbyname is not needed, the server receives messages and
replies to whoever sent them.
\break
It doesn't initiate interaction with another machine
\newslide

{\cprogram
if ((ppe=getprotobyname(transport))==0)
  errexit("...");
if (strcmp(transport,"udp")==0)
  type = SOCK_DGRAM;
else
  type = SOCK_STREAM;
@endprogram}

This is the same as in the client.

{\ltt{}transport} should be either {\ltt{}"tcp"}
or {\ltt{}"udp"}
\break
The error exit will not occur on either of these two,
it will only happen if it is called with some third
and unexpected value.
\vt
Now that we know the request is valid
we allocate the socket

{\ltt{}s=socket(PF_INET,type,ppe->p_proto);}

If this is a TCP request, this will be the master socket
to be used by the server.

If this is a UDP request, this will be the (only) socket
to be used by the server.
\newslide

{\cprogram
if (bind(s,(struct sockaddr *)&sin,sizeof(sin))<0)
  errexit("can't bind...");
@endprogram}

Remember, clients need to know where to find the server,
it's port must be known by the clients.
\break
Terminology: the server is at a {\bit well-known-address}

{\ltt{}bind} attachs the socket to the well-known-address

The port and address ({\ltt{}INADDR_ANY}) set up 
in the address structure previously are used.

Emphasis:
\break
The bind on the server uses the server's address(es) and port.
\break
The connect on the client uses the server's address and port.

A {\ltt{}bind} failure indicates wrong priviledge (not root) or
the port is already in use.
\break
Debugging: before testing your new version of a server, be sure to kill the
old version (or bind will fail).
When a server is killed, the port is not released immediately.

Two processes may be bound to the same port (using fork),
if the socket is set up before the fork.
\break
In this case one process (randomly) will get the connection/message.

\newslide

{\cprogram
if (type==SOCK_STREAM && listen(s,qlen)<0)
  errexit("can't listen...");
@endprogram}

{\ltt{}listen} is only done for TCP connections
\break
if the listen request for a tcp connection fails we error exit.
\break
after listen call, connections will be queued for acceptance.
\break
before listen call, the server is not available (not responding)

{\ltt{}qlen}: the maximum number of unaccepted clients that
are allowed to be waiting. (Usually $\le5$ required by system)
\vf
{\ltt{}return s;}

The socket is set up; it now may be used.
\break
Return the descriptor (number).

Review: either the socket correctly sets up or
{\ltt{}passivesock} causes the program to exit with
an error message.
\newslide
\centerline{\bbf Server vs. Client (Summary)}
\vt
\halign{
\vtop{\parindent=0pt\hsize=3.0in\hangindent0.3em\strut#\strut}
&\qquad
\vtop{\parindent=0pt\hsize=3.0in\hangindent0.3em\strut#\strut}\cr
{\bit Server}&{\bit Client}\cr
Bind/listen&Connect\cr
Specify server's address&Specify server's address\cr
Specifies own address&Specifies others address\cr
Uses the specified port&Uses any port\cr
Accepts connect or message from any port&Connects or sends to a specific port\cr
passivesock&connectsock\cr
}
\newslide
\centerline{\bbf The Connectionless Time Server (Details)}

see Section 9.4 for code

{\cprogram
int main(int argc, char *argv[])
{
  struct sockaddr_in fsin;
  char *service="time";
  char buf[1];
  int sock;
  time_t now;
  unsigned int alen;
@endprogram}

This is a UDP time server, it could be used by
your client.

In general, the main program will be similar for
all of Comer's servers and the difference will
be inside the procedure that the main program calls.
\break
In this case the server is simple and he places the
code (and variables) inside the main program.
\newslide

{\cprogram
switch (argc){
  case 1:
    break;
  case 2:
    service = argv[1];
    break
  default:
    errexit(...);
}
@endprogram}

This switch is similar to the client switch.

Normally this program will attach to the {\ltt{}"time"}
port;
\break
however, you can put an argument on the command line
that overrides that.

This allows testing on alternate ports before you do the
real install.

Normally the switch would be followed by a procedure call;
\break
but, as noted before, the code of this server
is embedded in the main program

\newslide


{\ltt{}sock=passiveUDP(service);}
\break
get a server socket (UDP type)

{\ltt{}while(1)}
\break
infinite loop (the server never exits)

{\ltt{}alen=sizeof(fsin)}

{\ltt{}alen} starts with the size of {\ltt{}fsin}, 

if the actual size of the sender's address is bigger than this, it won't fit 
in {\ltt{}fsin} and an error condition will occur.

Ends with the actual size of the senders address.

All internet address sturctures have the same size, so if this is not
equal to {\ltt{}sizeof(fsin)} something is wrong; notice the program
never checks.

\newslide
{\program
if (recvfrom(sock,buf,sizeof(buf),0,
          (struct sockaddr *)&fsin,&alen)<0)
    errexit("...");
\endprogram}

Receive a message. 
If there is an error, {\ltt{}recvfrom} returns a negative number 
and the server exits.

{\ltt{}buf}: the variable that the message is to be placed into.

{\ltt{}sizeof(buf)}: the message better be shorter than this

Actually this server ignores the contents of the incoming message.

{\ltt{}fsin}: (return address) 
the variable that gets the address of sender of the message.
\break
(Highly useful for sending a reply!)
\newslide
{\cprogram
time(&now);
now=htonl((unsigned long)(now+UNIXEPOCH));
@endprogram}

Get the information the client requested, in this case
the time and prepare for network shipment.

{\ltt{}UNIXEPOCH}: convert the number to conform to the protocol.
Here we are the system's network time server, so we must conform to the 
measure of time specified by the RFC.

In a client-server pair what matters is that both the client and server
agree on the format of the time.
They could agree either on UNIX or Internet, or some other; as long
as they agree.

{\ltt{}htonl}: by convention all numbers are converted to network standard
order for shipment.

\newslide
{\program
sendto(sock,&now,sizeof(now),0,
        (struct sockaddr *)&fsin,sizeof(fsin))
\endprogram}

Send the reply 

{\ltt{}sock}: use the same socket

{\ltt{}now}: send the number as a string of bytes.

{\ltt{}fsin}: send to the return address.

receive--the address is the source (return) address
\break
send--the address is the destination address
\break
(It's always the other machines address,
\break
because you should know your own.)
\vt
Note:

An attempt to {\ltt{}connectTCP} to this particular server would fail 
({\ltt{}connectsock} would get an error).
\break
This server does only UDP.
\newslide
\centerline{\bbf Summary}

1) Set up a UDP socket.

(Repeat)

2) Get an incoming request (save the reply address).

3) Perform the service or get the information.

4) Prepare the information for network transfer.

5) Send the reply.
\newslide
\centerline{\bbf Homework Help}
\vt
The {\ltt{}get_port} function is designed to drop into the Comer code.

Example of
using a function to return the service, where the function returns a string.

{\program
char *service = get_port();
\endprogram}
\bye
