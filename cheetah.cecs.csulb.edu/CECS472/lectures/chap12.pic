\def\chapternumber{Chapter 12 --- A Threaded Server -- 6 January 2009}
\input slides.tex
\centerline{\bbf Chapter 12}
\centerline{A Threaded Server}

{\bit Motivation:}
Threads give you concurrency, without as much overhead as processes.

{\bit Paradigm:}
A thread is a procedure call that runs simultaneously with the parent.

Variables local to the procedure are unique to the thread.

Global variables are shared by all threads.
\break
Common globals make it:
\break
1) easy to exhange data
\break
2) necessary to use mutual exclusion when accessing global data

The descriptor table is global (shared by all threads).

Downside: if any thread crashes, the process crashes taking all
threads with it.

Note: if any thread uses {\ltt{}exit()}, the process exits taking
all threads with it.
\newslide
\centerline{\bbf Creating A Thread}

{\cprogram
int pthread_create(
      pthread_t *thread,
      pthread_attr_t *attr,
      void *(*start_routine)(void *),
      void *arg);
@endprogram}

Return value: zero=OK, non-zero=error

{\ltt{}thread}: the thread identifier (similar to a processID)
is stored in the variable passed to this argument.

{\ltt{}attr}: special attributes the thread should have.

{\ltt{}start_routine}: the thread is this procedure.
When the procedure returns, the thread is done/terminated.
This procedure takes one argument (a pointer to something)
and returns one argument (a pointer to something).
Warning: type checking is often overridden for these values.

{\ltt{}arg}: This argument is to be passed to the thread procedure.
{\ltt{}start_routine} will see this as its single incoming argument.
\newslide
{\cprogram
int pthread_attr_init(pthread_attr_t *attr);
@endprogram}

Sets the all the attribute fields in the variable passed
to their default values.
Used to modify the attribute variable that will be used by the create.

\vf

{\cprogram
int pthread_attr_setdetachstate(
      pthread_attr_t *attr,
      int detachstate);
@endprogram}

The detach state attribute is either joinable, indicating
the parent thread can do a {\ltt{}pthread_join} to wait
for the child thread to exit.
Or detached, indicating the join will not be done.

This call modifies the attribute variable.
Do this before using the attribute varible to create the thread. 

Warning: joinable ties up some thread resouces until
the parent does do a join (recall the reaper problem).
If you use this be sure your main thread does join
on the exiting child threads.


\newslide

A Threaded server is very similar to the concurrent server
from Chapter 11.

This discussion will highlight the modification to the code from
Chapter 11.

We will do this twice. 

First time, the simple code.

We will do only echo with threads  which will be very
similar to the echo server from the previous chapter.
This will be only the basic echo service, without
the extra stats and mutex stuff that Comer adds..

Second time, Comer's TCP echo server code.

Comer's code adds some extra (unnecessary) things to the server.
These items maintain statistics about what the server had done.
Since all the threads place their information in the same
set of global variables they need to use of semaphores
to keep from having race conditions.

\newslide
\centerline{\bbf Simple Version}

The includes:

{\cprogram
#include <pthread.h>
@endprogram}

Only the above include needs to be added.
This is where the thread routines are defined.

{\cprogram
int main(int argc, char *argv)
{
  pthread_t th;
  pthread_attr_t ta;
  char *service="echo";
  ...
  switch
  ...
  msock = passiveTCP(service, QLEN);
@endprogram}

The only necessary differences are the at in this section
of code is the declaration of the two thread variables.

{\ltt{}th} is the thread.
\break
{\ltt{}ta} is the thread attributes.
\newslide
{\cprogram
msock = passiveTCP(service, QLEN);
(void) pthread_attr_init(&ta);
(void) pthread_attr_setdetachstate(&ta,
                 PTHREAD_CREATE_DETACHED);
while (1)
...
@endprogram}

The thread attribute variable is initialized to have defaults values.

The detach state is set to ``detached" as opposed to ``joinable".
\break
The main program can't do thread joins.
\break
The main program doesn't need to do thread joins to recover
thread resources.

\newslide

{\cprogram
while (1)
  ...
  ssock = accept...
  if (ssock < 0) ...
  if (pthread_create(&th, &ta, 
    (void * (*)(void *))TCPechod, (void *)ssock)<0)
     errexit("pthread_create:%s\n",strerror(errno));
}
@endprogram}

Again, the server waits at the {\ltt{}accept} call
until a client does a connect.
\break
The switch/fork of the last chapter is replaced
by a (simpler) call to create a thread.
\break
Since threads do not get copies of the global variables
(they share a single copy),
we don't need to (must not) close the msock and sock.
\break
The main program (parent) continues after the {\ltt{}pthead_create},
at the instruction after the if statement.
(Goes back around to the accept.)
\break
The new thread (child) continues with a procedure call to {\ltt{}TCPechod}.
When it returns from this call the thread terminates.
\break
If the create fails, error exit.
\newslide
{\centerline{\bbf Create Details}

{\cprogram
pthread_create(&th, &ta, 
  (void * (*)(void *))TCPechod, (void *)ssock)
@endprogram}

{\ltt{}th} is filled in with information about the thread.
This information is never used.
(In the last chapter, the pid returned by fork wasn't really used.)

{\ltt{}ta} says to do a ``detached" create.
(It is not modified.)

{\ltt{}TCPechod} is the procedure that is to be the thread.

{\ltt{}(void * (*)(void *)}: 
\break
{\ltt{}TCPechod} is: {\ltt{}int (*)(int)},
it takes an integer and returns an integer.
\break
Warning: this cast is drastically disabling type checking.

Meaning:
\break
A function/subroutine is an address {\ltt{}(*)}
\break
Has one parameter that is  a pointer ({\ltt{}void *})
\break
Returns a pointer.

{\ltt{}(void *)ssock}: the socket to talk to the client
will be passed as the parameter to the procedure when
that procedure is created
This allows the procedure to be the same as in the last chapter.
Again, type checking is being disabled.
\newslide
\centerline{\bbf TCPechod}

{\cprogram
int TCPechod(int fd)
{
...
  close(fd);
}
@endprogram}

Close the socket before the ``return".

\vt
\centerline{\bbf Summary}

Add one include.
\break
Add two thread related variables.
\break
Add two calls to initialize the thread attributes variable.
\break
Replace the {\ltt{}fork} switch with the {\ltt{}pthread_create} if.
\break
Close the socket before the thread completes (returns).

\vt
\centerline{\bbf Compiling With The pthread Library}

Only the standard library is automatically included,
\break
others need to be explicitly named.
\break
To explicitly name a library you use the {\ltt{}-l} option:
\break
{\ltt{}gcc myserver.c  -lpthread -o server.out}
\vfill

Note: Comer adds the statistic tracking and reporting
to the echo. These are extra, non-required items.
We will discuss these in the remainder of this lecture.

\newslide

\centerline{\bbf Mutual exclusion}

Comer enhanced code uses global variables to keep statics.

Because multiple thread are updating there variables,
access to these variable needs to use critical sections
and semaphores.

Because threads are in a single process they don't need
to use the global (interprocess semaphores).
They can use a less resource intensive set called thread
semaphores.

The thread semaphore utilities are:

Declare a semaphore:
\break
{\ltt{}pthread_mutex_t semaphore;}

Initialize a semaphore:
\break
{\ltt{}pthread_mutex_init(&semaphore);}

Lock: entering critical section ({\ltt{}wait}):
\break
{\ltt{}pthread_mutex_lock(&semaphore);}

Unlock: leaving critical section ({\ltt{}signal})
\break
{\ltt{}pthread_mutex_unlock(&semaphore);}

\newslide
\centerline{\bbf Enhanced echo}
\centerline{(Second Time)}

We emphasize, just the differences from simple version.

{\cprogram
#include <sys/resource.h>
@endprogram}

This include is so we can  track usage (resource) statistics.

\vt
{\cprogram
struct {
 pthread_mutex_t st_mutex;
 unsigned int st_concount;
 unsigned int st_contotal;
 unsigned int st_contime;
 unsigned int st_bytecount;
} stats;
@endprogram}

A global variable that keeps track of the statistics.

\vt
{\ltt{}prstats}: a procedure to print the statistics
found in the global variable. This procedure is
an infinite loop that does a print every 5 seconds.
\newslide

{\cprogram
(void) pthread_mutex_init(&stats.st_mutex,0);
@endprogram}

Initialize the semaphore. This must be done before creating
any threads.

\vt
{\cprogram
if (pthread_create(&th,&ta,
    (void*(*)void*)prstats,0)<0)
      errexit...
@endprogram}

Startup the thread (procedure that prints the statistics.

The remaining differences are in the procedures.

\vt
Side discussion: (the global variables)

{\ltt{}st_concount}: connection count. How many clients are 
connected right now. This is equal to the number of {\ltt{}TCPechod}
procedures that are running.

{\ltt{}st_contotal}: connection total. How many clients have
connected since the server started.

{\ltt{}st_conbytecount}: How many total bytes have been echoed
since the server started.

{\ltt{}st_contime}: Total of all client connection times in seconds.
\newslide
\centerline{\bbf Additions to TCPechod procedure}

{\cprogram
 time_t start;
 ...
 start = time(0);
@endprogram}

A local varible is used to compute the time we spend in this
call to the procedure. Copies of the local variables exist
in all threads so no locking is needed.
\vt

{\cprogram
(void) pthread_mutex_lock(&stats.st_mutex);
stats.st_concount++;
(void) pthread_mutex_unlock(&stats.st_mutex);
@endprogram}

Lock, change the global, unlock.

This code is done three separate places in this procedure.

\vf
\centerline{\bbf prstats summary}

lock, print stats, unlock, sleep 5 seconds.
\bye
