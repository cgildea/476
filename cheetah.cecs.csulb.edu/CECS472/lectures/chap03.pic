\def\chapternumber{Chapter 3 --- Concurrency -- 13 August 2008}
\input slides.tex
\input bigcstuff.tex
\centerline{\bbf Chapter 3}
\centerline{Concurrency}
\vt

Problem: How to handle multiple requests for service

Multiuser systems: users make requests
\break
Networks: machines make requests

Concurrency: the ability to handle multiple requests at the same
time.
\vt
All multiuser systems provide concurrency,

Most single user system provide it.

Concurrency Terms:
\vt
Multiple processes/Multiprocessing
\break
Multiple tasks/Multi-tasking
\break
Multiple threads
\newslide
\centerline{\bbf Two Kinds of Servers}
\vt
{\bit Iterative}
\ind{--} Server handles one client at a time
\ind{--} Usable if services takes a short time
\ind{--} Examples: time-of-day, ping
\ind{--} Disadvantage: one slow client can block others
\vt
{\bit Concurrent}
\ind{--} Creates a process/task/thread for each client
\ind{--} Allows long running service
\ind{--} Examples: telnet, ftp
\ind{--} Disadvantage: process creation is a heavy-weight operation
\newslide
\centerline{\bbf Unix Processes}
\vt
Fundamental unit of concurrency

Created by the {\ltt{}fork()} command.

A process is always created by another process.

Terminology:
\break
Creating process: parent
\break
Created process: child

A child is a separate copy of the parent
\break
(including a separate copy of all variables)

Each runs independent of the other 
\break
(unless the programmer deliberately builds in some sort of synchronization)

Each process is given a unique id number (pid) by the operating system
\newslide
\centerline{\bbf Example of Process Creation}
\vt
{\cprogram
#include <stdio.h>
int sum;
int main () {
  int i;
  sum = 0;
  fork();  /* create a new process */
  for (i=1; i<=10000 ; i++) {
    sum += i;
    printf("sum is %d\n", sum);
    fflush(stdout);
  }
  return 0;  // or exit(0);
}
@endprogram}

\vt
Both parent and child print 10000 lines.
\break
both have separate {\ltt{}i} and {\ltt{}sum} variables

Output depends on the time slice and I/O buffering:

{\program
sum is 1
sum is 3
sum is 1
sum is 3
sum is 6
\endprogram}
\newslide
\centerline{\bbf Operating System Issues}
\vt
Timeslicing: each runnable process gets an allocation of CPU time.

Switching processes costs overhead so:
\break
the bigger the time slice the less over head
\break
the smaller the time slice the more frequently each process makes progress

Multiple CPU machine will have several processes running at once
\vt
Efficiency issue:

A design that context switches too often will use too much overhead 
(and will run slow).
\newslide
\centerline{\bbf Concurrent Server Example}
\vt
{\cprogram
#include <stdio.h>
int main () {
  int pid;
  char ch = 'y';
  while (ch != 'x') {
    printf("hit return for another process");
    getc(ch);
    pid = fork();  /* create a new process */
    if (pid != 0){
      printf("original/parent\n");
    } else {
      printf("new/child\n");
      exit(0);  /* don't forget this or this:
        execl("/bin/ls", NULL); */
    }
  }
  return 0;
}
@endprogram}

Creates one child per iteration.

Child does something then exits.

Warning: missing exit gets you exponentially many processes.
\newslide
\centerline{\bbf I/O and Concurrency}

Problem: Several things are/may happen at once, including I/O.
\item{}In Unix all I/O is considered file I/O.

Serial: Read and wait for the information to arrive.
\vt
Conditional: Read information if available, otherwise continue

Solution: 
tell read to return {\ltt{}-1} if nothing available, otherwise it reads
normally 
\break
(use {\ltt{}ioctl} to set non-blocking I/O)

Solution: see what files have something available to read,
read only from those with input available
\break
(use the {\ltt{}select} to see what has input)

\bye
