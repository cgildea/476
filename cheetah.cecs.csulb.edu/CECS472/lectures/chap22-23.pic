\def\chapternumber{Chapter 22/23 --- RPCGEN -- 22 April 2010}
\input slides.tex
\centerline{\bbf Chapter 22/23}
\centerline{Building Remote Procedure Calls}

Problem: RPC headers are complicated (but repetitive)

Caller: Build message, call service with correct program numbers, specify
where arguments come from/go to, generate authentication, wait for reply.

Server: Need to register service, accept calls (including authentication), 
handle arguments, build reply, send reply

Problem: The arguments have to be correctly XDRd,
\break
the XDR routine must match the argument types.

Solution: Automate the processes. (RPC compiler)
\break
Automatically generate as much of the code as possible.
\break
Given the argument types, generate the XDR routines.

{\bit Stub procedures:}
normal procedure.
\break
Stub does all rpc handling,
\break
Effect: Stub hides RPC complexities

Good programming style: Hide all this stuff.

Solution: build interface procedures that hide the stub procedures.

\newslide
\centerline{\bbf Client-Side Stubs and Interfaces}

Client interface makes calls look like original procedure.
\break
(Hides peculiarities of stub from main program)

Client stub has procedure name similar to server stub.

Stub builds the XDR stream, authentication and other parts of the call.

Stub Connects to the remote procedure.
\vt
{\railroadfont
.PS
boxh=0.4i
vgap=0.4i
Main: box wid 3i ht boxh "Main Program"
Cif: box wid 3i ht boxh with .n at Main.s + (0,-vgap)  "Client-Side Interface"
Clnt: box wid 3i ht boxh with .n at Cif.s + (0,-vgap)   "Client Stub"
Callm: line -> down vgap from 1/2 between Main.sw and Main.s
Rtnm: line <- down vgap from 1/2 between Main.s and Main.se
Callcif: line -> down vgap from 1/2 between Cif.sw and Cif.s
Rtncif: line <- down vgap from 1/2 between Cif.s and Cif.se
Callclnt: line -> down vgap from 1/2 between Clnt.sw and Clnt.s
Rtnclnt: line <- down vgap from 1/2 between Clnt.s and Clnt.se
" call" at Callm.c ljust
" call" at Callcif.c ljust
" call" at Callclnt.c ljust
" return" at Rtnm.c ljust
" return" at Rtncif.c ljust
" return" at Rtnclnt.c ljust

Proc: box wid 3i ht boxh with .w at Main.e + (0.5i,0) "Service Procedures"
Sif: box wid 3i ht boxh with .n at Proc.s +(0,-vgap)  "Server-Side Interface"
Svc: box wid 3i ht boxh with .n at Sif.s + (0,-vgap)  "Dispatcher"
Callp: line <- down vgap from 1/2 between Proc.s and Proc.se
Rtnp: line -> down vgap from 1/2 between Proc.s and Proc.sw
Callsif: line <- down vgap from 1/2 between Sif.s and Sif.se
Rtnsif: line -> down vgap from 1/2 between Sif.sw and Sif.s
Callsvc: line <- down vgap from 1/2 between Svc.s and Svc.se
Rtnsvc: line -> down vgap from 1/2 between Svc.sw and Svc.s
" call" at Callp.c ljust
" call" at Callsif.c ljust
" call" at Callsvc.c ljust
" return" at Rtnp.c ljust
" return" at Rtnsif.c ljust
" return" at Rtnsvc.c ljust
Net: box wid 6.5i ht 0.5i with .ne at Svc.se + (0,-vgap) "Network"
.PE
\centerline{\box\graph}}

\vt
The more complicated separation will be used so parts can be 
generated by software.
\newslide
\centerline{\bbf Server-Side Dispatcher and Interfaces}

Call arrives at dispatcher.

Dispatcher examines procedure number and 
\break
calls correct server-side interface procedure.

Server interface calls real procedure.
\break
(Hides peculiarities of dispatcher from service procedures)
\vt
{\railroadfont
.PS
boxh=0.4i
vgap=0.4i
Main: box wid 3i ht boxh "Main Program"
Cif: box wid 3i ht boxh with .n at Main.s + (0,-vgap)  "Client-Side Interface"
Clnt: box wid 3i ht boxh with .n at Cif.s + (0,-vgap)   "Client Stub"
Callm: line -> down vgap from 1/2 between Main.sw and Main.s
Rtnm: line <- down vgap from 1/2 between Main.s and Main.se
Callcif: line -> down vgap from 1/2 between Cif.sw and Cif.s
Rtncif: line <- down vgap from 1/2 between Cif.s and Cif.se
Callclnt: line -> down vgap from 1/2 between Clnt.sw and Clnt.s
Rtnclnt: line <- down vgap from 1/2 between Clnt.s and Clnt.se
" call" at Callm.c ljust
" call" at Callcif.c ljust
" call" at Callclnt.c ljust
" return" at Rtnm.c ljust
" return" at Rtncif.c ljust
" return" at Rtnclnt.c ljust

Proc: box wid 3i ht boxh with .w at Main.e + (0.5i,0) "Service Procedures"
Sif: box wid 3i ht boxh with .n at Proc.s +(0,-vgap)  "Server-Side Interface"
Svc: box wid 3i ht boxh with .n at Sif.s + (0,-vgap)  "Dispatcher"
Callp: line <- down vgap from 1/2 between Proc.s and Proc.se
Rtnp: line -> down vgap from 1/2 between Proc.s and Proc.sw
Callsif: line <- down vgap from 1/2 between Sif.s and Sif.se
Rtnsif: line -> down vgap from 1/2 between Sif.sw and Sif.s
Callsvc: line <- down vgap from 1/2 between Svc.s and Svc.se
Rtnsvc: line -> down vgap from 1/2 between Svc.sw and Svc.s
" call" at Callp.c ljust
" call" at Callsif.c ljust
" call" at Callsvc.c ljust
" return" at Rtnp.c ljust
" return" at Rtnsif.c ljust
" return" at Rtnsvc.c ljust
Net: box wid 6.5i ht 0.5i with .ne at Svc.se + (0,-vgap) "Network"
.PE
\centerline{\box\graph}}
\vt
Using ``interfaces" the main program needs a couple lines added and the 
real procedures don't need to be changed.
\newslide
\centerline{\bbf Methodology}
\centerline{How to Build RPC Programs}

1) Build a well modularized program

{\railroadfont
.PS
Pr: box wid 4i ht 1.5i
Prw: box wid 2i ht 1.5i with .w at Pr.w "Main" "Program"
Pre: box wid 2i ht 1.5i with .e at Pr.e "Service" "Routines"
.PE
\centerline{\box\graph}}
\vf
2) Split the program.
Add prototypes for the service routines to the main program.

{\railroadfont
.PS
Main: box wid 2i ht 1.5i "Main Program" "plus prototypes"
Proc: box wid 2i ht 1.5i with .w at Main.e + (1.5i,0)  "Service" "Routines"
Callp: line -> right 1.5i from 1/2 between Main.e and Main.ne
Rtnp: line <- right 1.5i from 1/2 between Main.e and Main.se
"call" at Callp.c above
"return" at Rtnp.c above
.PE
\centerline{\box\graph}}
\newslide
\centerline{\bbf Build RPC Stuff}

3) Build the {\ltt{}.x} file.
\break
This defines exactly what will be passed over the network.

4) Add the necessary lines to the main program

5) Build the Client and Server interfaces.
\vt
{\railroadfont
.PS
boxh=0.8i
vgap=0.4i
Main: box wid 2i ht boxh "Main Program" "(RPC lines added)"
Proc: box wid 2i ht boxh with .w at Main.e + (1.5i,0)  "Service Routines"
Cif: box wid 2i ht boxh with .n at Main.s + (0, -vgap) "Client Interface" "cif file"
Sif: box wid 2i ht boxh with .n at Proc.s + (0, -vgap)  "Server Interface" "sif file"
Gen: box wid 2i ht boxh with .n at 1/2 between Cif.se and Sif.sw + (0, -0.5i) "the rpc" ".x file"
Callm: line -> down vgap from 1/2 between Main.s and Main.sw
Rtnm: line <- down vgap from 1/2 between Main.s and Main.se
Rtnp: line -> down vgap from 1/2 between Proc.s and Proc.sw
Callp: line <- down vgap from 1/2 between Proc.s and Proc.se
" call" at Callm.c ljust
" return" at Rtnm.c ljust
" call" at Callp.c ljust
" return" at Rtnp.c ljust
.PE
\centerline{\box\graph}}
\newslide
\centerline{\bbf Apply rpcgen}

This generates the stubs, the dispatcher, the XDR routines and the header
({\ltt{}.h}) file.

The dispatcher and server stubs are placed in the svc file.


{\railroadfont
.PS
boxh=0.8i
vgap=0.4i
Main: box wid 2i ht boxh "Main Program" "(RPC lines added)"
Proc: box wid 2i ht boxh with .w at Main.e + (2.5i,0)  "Service Routines"
Cif: box wid 2i ht boxh with .n at Main.s + (0, -vgap) "Client Interface" "cif file"
Sif: box wid 2i ht boxh with .n at Proc.s + (0, -vgap)  "Server Interface" "sif file"
Gen: box wid 2i ht boxh with .n at 1/2 between Cif.se and Sif.sw + (0, -vgap) "the rpc" ".x file"
Callm: line -> down vgap from 1/2 between Main.s and Main.sw
Rtnm: line <- down vgap from 1/2 between Main.s and Main.se
Rtnp: line -> down vgap from 1/2 between Proc.s and Proc.sw
Callp: line <- down vgap from 1/2 between Proc.s and Proc.se
" call" at Callm.c ljust
" return" at Rtnm.c ljust
" call" at Callp.c ljust
" return" at Rtnp.c ljust
Xdr: box dashed wid 2i ht boxh with .n at Gen.s + (0, -vgap/2) "XDR routines" "xdr file"
Hf: box dashed wid 2i ht boxh with .n at Xdr.s + (0, -vgap/2) ".h file"
Clnt: box dashed wid 2i ht boxh with .n at Cif.s + (0, -3*boxh-2*vgap) "client stubs" "clnt file"
Svc: box dashed wid 2i ht boxh with .n at Sif.s + (0,-3*boxh-2*vgap) "dispatcher" "svc file"
Callcif: line -> down 3*boxh+2*vgap from 1/2 between Cif.s and Cif.sw
Rtncif: line <- down 3*boxh+2*vgap from 1/2 between Cif.s and Cif.se
Rtnsif: line -> down 3*boxh+2*vgap from 1/2 between Sif.s and Sif.sw
Callsif: line <- down 3*boxh+2*vgap from 1/2 between Sif.s and Sif.se
" call" at Callcif.c ljust
" return" at Rtncif.c ljust
" call" at Callsif.c ljust
" return" at Rtnsif.c ljust
Net: box dashed wid 6.5i ht 0.5i with .ne at Svc.se + (0,-vgap) "Network"
Callnc: line -> down vgap from 1/2 between Clnt.s and Clnt.sw
Returnc: line <- down vgap from 1/2 between Clnt.s and Clnt.se
Returnns: line -> down vgap from 1/2 between Svc.s and Svc.sw
Calls: line <- down vgap from 1/2 between Svc.s and Svc.se
.PE
\centerline{\box\graph}}

\newslide
\centerline{\bbf Split Main Program with Prototypes}
{\cprogram
/* File: convert_client.c */
/* Convert a sentence to upper or lower case */
void upper_it(char *sentence);
void lower_it(char *sentence);
int main() {
  char buffer[100]; /* holds the sentence */
  char whichway[5]; /* to upper or to lower */
  /* control-C to exit */
  for (;;) {
    printf("enter the string ");
    gets(buffer);
    printf("u) to upper, l) to lower? ");
    gets(whichway);
    switch (whichway[0]) {
      case 'u':
        upper_it(buffer);
        break;
      case 'l':
        lower_it(buffer);
        break;
      default:
        printf("unrecognized option\n");
    }
    printf("%s\n", buffer);
  }
}
@endprogram}
\newslide
\centerline{\bbf Original Service Procedures}
{\program
/* File: convert_services.c */
#include <ctype.h>  /* toupper, tolower*/
/* Convert a sentence to upper or lower case */
void upper_it(char *sentence){
  char *letter = sentence;
  while (*letter) {
    *letter = toupper(*letter);
    letter++;
  }
}
void lower_it(char *sentence){
  char *letter = sentence;
  while (*letter) {
    *letter = tolower(*letter);
    letter++;
  }
}
\endprogram}
\vt
Main program and service procedures nicely separated
\newslide
\centerline{\bbf Building the rpcgen File}

{\ltt{}convert.x}:

{\program
/* convert.x */
%#include "Anything.h"
program CONVERTPROG { 
  version CONVERTVER {
    string UPPER_IT(string) = 1;  /* procedure 1 */
    string LOWER_IT(string) = 2;  /* procedure 2 */
  } = 1;                       /* version number */
} = 0x20000064;                /* program number */ 
\endprogram}

\vt
The user gives the program number, the version number, the
parameter lists and return types of the RPCs and the RPC numbers.
{\ltt{}%} passes the {\ltt{}include} to the {\ltt{}convert.h} file.

Example ({\ltt{}LOWER_IT}): 
Creates {\ltt{}lower_it_1} as procedure number 2.
It will take a string and return a string.
The {\ltt{}_1} will match the version 

This file is used by rpcgen to build the following files:

{\ltt{}convert_svc.c} -- 
dispatcher
\break
{\ltt{}convert_clnt.c} -- 
client stubs
\break
{\ltt{}convert_xdr.c} -- 
any special xdr routines required by parameters or return values.
In this example none are required so the file is not created.
\break
{\ltt{}convert.h} --
the header file

\newslide
\centerline{\bbf Header File}

This file ({\ltt{}convert.h}) will be created when rpcgen is run.


{\program
#include "Anything.h"
#define CONVERTPROG ((u_long)0x20000064)
#define CONVERTVER ((u_long)1)
#define UPPER_IT ((u_long)1)
extern char **upper_it_1(char **, CLIENT *);
extern char **upper_it_1_svc(char **, 
                                  struct svc_req *);
#define LOWER_IT ((u_long)2)
extern char **lower_it_1(char **, CLIENT *);
extern char **lower_it_1_svc(char **,
                                  struct svc_req *);
\endprogram}

Defines the program number.
\break
Defines the procedure numbers.
\break
Names the procedures ({\ltt{}extern})
\break
{\ltt{}upper_it_1} and {\ltt{}lower_it_1} are called
by the client-side interface.
\break
{\ltt{}upper_it_1_svc} and {\ltt{}lower_it_1_svc} are 
what the server (dispatcher) calls.

Note that {\ltt{}UPPER_IT} gets ``defined" as a 1;
\break
don't use lower case or else {\ltt{}upper_it} will get ``defined";
\break
this definition will conflict with the name of your procedure 
(also called {\ltt{}upper_it}) and create a syntax error.
\newslide
\centerline{\bbf Main Program--RPC Version}

{\program
/* Convert a sentence to upper or lower case */
#include <rpc/rpc.h>
#include "convert.h"
CLIENT *handle;
void upper_it(char *sentence);
void lower_it(char *sentence);

main() {
  char buffer[100]; /* holds the sentence */
  char whichway[5]; /* to upper or to lower */
  if ((handle = clnt_create("cheetah",
   CONVERTPROG, CONVERTVER, "tcp")) == NULL) {
    /* print the error message */
    clnt_pcreateerror("convert client");
    exit(-1);
  }
      
  /* control-C to exit */
  ... same from hear on
}
\endprogram}

The only things added are the includes, the {\ltt{}handle} variable
and the call to {\ltt{}clnt_create}.

The {\ltt{}clnt_create} initializes the rpc's to point to the convert server
program on cheetah.

Note: Service routines are not changed at all.
\newslide
\centerline{\bbf A More Flexible Main Program}

Our main always looked for the server on cheetah.

It would be better if it allowed a command line argument to specify the host 
and it defaulted to localhost.

This can be done by adding some of Comer's code:

{\program
char *host = "localhost"
switch (argc) {
case 2: host = argv[1];
...
if (( handle = clnt_create(host, ...
\endprogram}

\newslide
\centerline{\bbf The Client-Side Interface (cif)}

{\program
#include <rpc/rpc.h>
#include "convert.h"
/* convert_cif.c */
extern CLIENT *handle;
void upper_it(char *sentence){
  char **answer;
  answer = upper_it_1(&sentence, handle);
  strcpy(sentence, *answer);
}
void lower_it(char *sentence){
  char **answer;
  answer = lower_it_1(&sentence, handle);
  strcpy(sentence, *answer);
}
\endprogram}
\vt
Interface to main program is the same.

Makes calls to the actual rpc.
\break
Must pack arguments into the parameter structure
\break
and unpack them from the answer structure.
\newslide
\centerline{\bbf The Server-Side Interface (sif)}

{\program
/* convert_sif.c */
#include <rpc/rpc.h>
#include "convert.h"
void upper_it(char *sentence);
void lower_it(char *sentence);
static char buffer[100];
static char *bufptr = buffer;
char **upper_it_1_svc(char **sentence, 
                    struc svc_req *dummy){
  strcpy(buffer, *sentence);
  upper_it(buffer);
  return &bufptr;  /* yeilds &buffer */ 
}
char **lower_it_1_svc(char **sentence)
                    struc svc_req *dummy){
  strcpy(buffer, *sentence);
  lower_it(buffer);
  return &bufptr;  /* yeilds &buffer */ 
}
\endprogram}

These procedures are called by the dispatcher.
\break
They must unpack arguments from the parameter structure
and pass them to the actual service routines.
\break
They must pack answer into the answer structure.
\break
The answer structure ({\ltt{}buffer}, {\ltt{}bufptr}) must be static.
\break
Note: {\ltt{}&buffer} is not correct C.
\newslide
\centerline{\bbf Client Stub (created by rpcgen)}

The file  {\ltt{}convert_clnt.c}:

{\program
#include <rpc/rpc.h>
#include "convert.h"
/* Default timeout can be changed */
static struct timeval TIMEOUT = { 25, 0 };
char **upper_it_1(argp, clnt)
  char **argp;
  CLIENT *clnt;
{ static char *res;
  bzero(&res, sizeof(res));
  if (clnt_call(clnt, UPPER_IT, xdr_wrapstring,
    argp, xdr_wrapstring, &res, TIMEOUT) 
     != RPC_SUCCESS) {
    return (NULL);
  }
  return (&res);
}
\endprogram}

Lower it is same except for name change.
\break
{\ltt{}clnt_call}: actual rpc call
\break
{\ltt{}xdr_wrapstring}: xdr conversion for parameter
\break
{\ltt{}argp}: parameter
\break
{\ltt{}xdr_wrapstring}: xdr conversion for result
\break
{\ltt{}res}: pointer to answer structure
\newslide
\centerline{\bbf Dispatcher (created by rpcgen)}

Makes the {\ltt{}upper_it} and {\ltt{}lower_it} rpc's available.
\break
Two parts, registration, actual dispatcher
\break
{\ltt{}convert_svc.c}: registration portion (stripped)

{\program
#include <stdio.h>
#include <rpc/rpc.h>
#include "convert.h"
static void convertprog_1(); /* dispatcher */
main()
{ SVCXPRT *transp;
  (void)pmap_unset(CONVERTPROG, CONVERTVER);
  /* create a udp service */
  transp = svcudp_create(RPC_ANYSOCK);
  /* register the udp version of the rpc */
  svc_register(transp, CONVERTPROG, CONVERTVER,
    convertprog_1, IPPROTO_UDP));
  /* create a tcp service */
  transp = svctcp_create(RPC_ANYSOCK, 0, 0);
  /* register the tdp version of the rpc */
  svc_register(transp, CONVERTPROG, CONVERTVER,
    convertprog_1, IPPROTO_TCP));
  /* run the dispatcher-dispatcher */
  svc_run();
}
\endprogram}
\newslide
\centerline{\bbf Actual Dispatcher}
\centerline{Called for each RPC}

{\program
static void convertprog_1(rqstp, transp)
{ a bunch of local variables including:
  char *(*local)();
  /* Set the function to call */
  switch (rqstp->rq_proc) {
  /* Direct call */
  case NULLPROC: (void)svc_sendreply(...
    return;
  case UPPER_IT:
    /* call set up, xdr to use, who to call */
    xdr_argument = xdr_wrapstring;
    xdr_result = xdr_wrapstring;
    local = (char *(*)(char*, 
              struct svc_req *)) upper_it_1_svc;
    break;
  case LOWER_IT: -- similar ... }
  /* line up arguments */
  bzero(&argument, sizeof(argument));
  svc_getargs(transp, xdr_argument, &argument));
  /* call the procedure */
  result = (*local)(&argument, rqstp);
  /* send back the result */
  svc_sendreply(transp, xdr_result, result));
  /* clean up */
  svc_freeargs(transp, xdr_argument, &argument));}
\endprogram}
\newslide
\centerline{\bbf Vector Program Example}
\centerline{Split Main Program with Prototypes}

{\cprogram
/* Vector operations interface */
#include "vectora.h"
void add(struct vector *a, struct vector *b, 
   struct vector *c);
main() {
    struct vector p,q,r;
    p.x = 1;
    p.y = 4;
    q.x = 2;
    q.y = 5;
    add(&p, &q, &r);
    printf("answer (should be (3, 9)): %d, %d\n", 
      r.x, r.y);
}
@endprogram}

\centerline{Service Routines}

First two parameters are to be added,
\break
result returned using the third parameter.
\break
Structures are passed by address.

{\program
#include "vectora.h"
void add(struct vector *a, struct vector *b, 
   struct vector *c) {
  c->x = a->x + b->x;
  c->y = a->y + b->y;
}
\endprogram}
\newslide
\centerline{\bbf The rpcgen File}

For illustration purposes we pass the parameters and
return the result using arrays.

{\program
/* The structures used by the actual rpc calls. */

/* two vectors will be passed */
struct pass {
  int data[4];
  };

/* one vector will come back */
struct answer {
  int data[2];
  };

program VECTORPROG { 
  version VECTORVER {
    answer ADD(pass) = 1;  /* procedure 1 */
  } = 1;                   /* version number */
} = 0x20000064;            /* program number */ 
\endprogram}
\newslide
\centerline{\bbf Main Program--RPC Version}

{\cprogram
#include <rpc/rpc.h>
#include "vector.h"
CLIENT *handle;
#include "vectora.h"
void add(struct vector *a, struct vector *b, 
   struct vector *c);
main() {
    struct vector p,q,r;
     if ((handle = clnt_create("cheetah",
      VECTORPROG, VECTORVER, "tcp")) == NULL) {
        /* couldn't connect to the server */
        clnt_pcreateerror("vector client");
        exit(-1);
    }
    p.x = 1;
    p.y = 4;
    q.x = 2;
    q.y = 5;
    add(&p, &q, &r);
    printf("answer (should be (3, 9)): %d, %d\n", 
      r.x, r.y);
}
@endprogram}

Only handle stuff and header lines are added.
\newslide
\centerline{\bbf The Client-Side Interface (cif)}

Incorrect packing and unpacking will cause a
program crash (segfault, or bus error).

{\program
#include <rpc/rpc.h>
#include "vectora.h"
#include "vector.h"
extern CLIENT *handle;

void add(struct vector *a, struct vector *b, 
   struct vector *c) {
  struct pass params;
  struct answer *result;
  /* pack up the parameters a and b */
  params.data[0] = a->x;
  params.data[1] = a->y;
  params.data[2] = b->x;
  params.data[3] = b->y;
  /* call the remote function */
  result = add_1(&params, handle);
  /* unpack the answer into c */
  c->x = result->data[0];
  c->y = result->data[1];
}
\endprogram}

{\bit One} (pointer to a) parameter, one handle

\newslide
\centerline{\bbf The Server-Side Interface (sif)}

If the answer is not packed into a static variable,
it will be deallocated on return from the sif and
the area pointed to will be reused
leaving you with garbage.

{\program
#include <rpc/rpc.h>
#include "vectora.h"
#include "vector.h"
void add(struct vector *a, struct vector *b, 
   struct vector *c);
answer *add_1_svc(pass *param, 
                       struct svc_req *dummy) {
  struct vector p,q,r;
  static struct answer result;
  /* unpack the parameters */
  p.x = param->data[0];
  p.y = param->data[1];
  q.x = param->data[2];
  q.y = param->data[3];
  add(&p,&q,&r); /* call the actual procedure */
  /* pack up the answer */
  result.data[0] = r.x;
  result.data[1] = r.y;
  return &result; /* return the answer */
}
\endprogram}

{\bit One} (pointer to a) parameter,
{\bit one} (pointer to a) result.

\newslide
\centerline{\bbf xdr File (created by rpcgen)}

rpcgen will create {\ltt{}vector_xdr.c}
\break
this file has the xdr routines

{\program
#include <rpc/rpc.h>
#include "vector.h"

bool_t xdr_pass(xdrs, objp)
 XDR *xdrs;
 pass *objp;
{
 if (!xdr_vector(xdrs, (char *)objp->data, 4, 
  sizeof(int), xdr_int)) {return (FALSE);}
 return (TRUE);
}

bool_t xdr_answer(xdrs, objp)
  XDR *xdrs;
  answer *objp;
{
  if (!xdr_vector(xdrs, (char *)objp->data, 2, 
    sizeof(int), xdr_int)) {return (FALSE);}
  return (TRUE);
}
\endprogram}

xdr the vector using by xdr-ing an int 4/2 times
\bye
